# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `bson` gem.
# Please instead update this file by running `bin/tapioca gem bson`.

module BSON
  class << self
    def ObjectId(string); end
  end
end

module BSON::Array
  def as_extended_json(**options); end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  def to_bson_normalized_value; end
  def to_bson_object_id; end
end

BSON::Array::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Array::ClassMethods
  def from_bson(buffer, **options); end
end

BSON::BINARY = T.let(T.unsafe(nil), String)

class BSON::Binary
  include ::BSON::JSON

  def initialize(data = T.unsafe(nil), type = T.unsafe(nil)); end

  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
  def data; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  def to_uuid(representation = T.unsafe(nil)); end
  def type; end

  private

  def validate_type!(type); end

  class << self
    def from_bson(buffer, **options); end
    def from_uuid(uuid, representation = T.unsafe(nil)); end
  end
end

BSON::Binary::BSON_TYPE = T.let(T.unsafe(nil), String)

class BSON::Binary::InvalidType < ::RuntimeError
  def initialize(type); end

  def message; end
  def type; end
end

BSON::Binary::SUBTYPES = T.let(T.unsafe(nil), Hash)
BSON::Binary::TYPES = T.let(T.unsafe(nil), Hash)

class BSON::Boolean
  def bson_type; end

  class << self
    def from_bson(buffer, **options); end
  end
end

BSON::Boolean::BSON_TYPE = T.let(T.unsafe(nil), String)

class BSON::ByteBuffer
  def initialize(*_arg0); end

  def get_array(*_arg0); end
  def get_byte; end
  def get_bytes(_arg0); end
  def get_cstring; end
  def get_decimal128_bytes; end
  def get_double; end
  def get_hash(*_arg0); end
  def get_int32; end
  def get_int64; end
  def get_string; end
  def get_uint32; end
  def length; end
  def put_array(_arg0, _arg1); end
  def put_byte(_arg0); end
  def put_bytes(_arg0); end
  def put_cstring(_arg0); end
  def put_decimal128(_arg0, _arg1); end
  def put_double(_arg0); end
  def put_hash(_arg0, _arg1); end
  def put_int32(_arg0); end
  def put_int64(_arg0); end
  def put_string(_arg0); end
  def put_symbol(_arg0); end
  def put_uint32(_arg0); end
  def read_position; end
  def replace_int32(_arg0, _arg1); end
  def rewind!; end
  def to_s; end
  def write_position; end
end

class BSON::Code
  include ::BSON::JSON

  def initialize(javascript = T.unsafe(nil)); end

  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
  def javascript; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end

  class << self
    def from_bson(buffer, **options); end
  end
end

BSON::Code::BSON_TYPE = T.let(T.unsafe(nil), String)

class BSON::CodeWithScope
  include ::BSON::JSON

  def initialize(javascript = T.unsafe(nil), scope = T.unsafe(nil)); end

  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
  def javascript; end
  def scope; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end

  class << self
    def from_bson(buffer, **options); end
  end
end

BSON::CodeWithScope::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Config
  extend ::BSON::Config

  def validating_keys=(value); end
  def validating_keys?; end
end

BSON::DATE_REFERENCE = T.let(T.unsafe(nil), Integer)

module BSON::Date
  def bson_type; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
end

module BSON::DateTime
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
end

class BSON::DbPointer
  include ::BSON::JSON

  def initialize(ref, id); end

  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
  def id; end
  def ref; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end

  class << self
    def from_bson(buffer, **options); end
  end
end

BSON::DbPointer::BSON_TYPE = T.let(T.unsafe(nil), String)

class BSON::Decimal128
  include ::BSON::JSON

  def initialize(object); end

  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def to_big_decimal; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  def to_s; end
  def to_str; end

  private

  def set_bits(low, high); end

  class << self
    def from_bits(low, high); end
    def from_bson(buffer, **options); end
    def from_string(string); end
  end
end

BSON::Decimal128::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Decimal128::Builder
  extend ::BSON::Decimal128::Builder

  def parts_to_bits(significand, exponent, is_negative); end

  private

  def valid_exponent?(exponent); end
  def valid_significand?(significand); end
  def validate_range!(exponent, significand); end
end

class BSON::Decimal128::Builder::FromBigDecimal
  def initialize(big_decimal); end

  def bits; end

  private

  def special?; end
  def to_bits; end
  def to_special_bits; end
end

class BSON::Decimal128::Builder::FromString
  def initialize(string); end

  def bits; end

  private

  def clamp(exponent, significand); end
  def round_exact(exponent, significand); end
  def special?; end
  def to_bits; end
  def to_special_bits; end
  def validate_format!; end
end

BSON::Decimal128::Builder::FromString::INFINITY_REGEX = T.let(T.unsafe(nil), Regexp)
BSON::Decimal128::Builder::FromString::NAN_REGEX = T.let(T.unsafe(nil), Regexp)
BSON::Decimal128::Builder::FromString::SCIENTIFIC_EXPONENT_REGEX = T.let(T.unsafe(nil), Regexp)
BSON::Decimal128::Builder::FromString::SIGNIFICAND_WITH_LEADING_ZEROS_REGEX = T.let(T.unsafe(nil), Regexp)
BSON::Decimal128::Builder::FromString::SIGN_AND_DIGITS_REGEX = T.let(T.unsafe(nil), Regexp)
BSON::Decimal128::Builder::FromString::TRAILING_ZEROS_REGEX = T.let(T.unsafe(nil), Regexp)
BSON::Decimal128::Builder::FromString::VALID_DECIMAL128_STRING_REGEX = T.let(T.unsafe(nil), Regexp)
BSON::Decimal128::Builder::INFINITY_MASK = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::Builder::NAN_MASK = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::Builder::SIGN_BIT_MASK = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::Builder::SNAN_MASK = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::Builder::TWO_HIGHEST_BITS_SET = T.let(T.unsafe(nil), Integer)

class BSON::Decimal128::Builder::ToString
  def initialize(decimal128); end

  def string; end

  private

  def bits_to_significand; end
  def create_string; end
  def exponent; end
  def high_bits; end
  def infinity?; end
  def low_bits; end
  def nan?; end
  def negative?; end
  def scientific_exponent; end
  def significand; end
  def two_highest_bits_set?; end
  def use_scientific_notation?; end
end

BSON::Decimal128::Builder::ToString::INFINITY_STRING = T.let(T.unsafe(nil), String)
BSON::Decimal128::Builder::ToString::NAN_STRING = T.let(T.unsafe(nil), String)
BSON::Decimal128::EXPONENT_OFFSET = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::EXTENDED_JSON_KEY = T.let(T.unsafe(nil), String)

class BSON::Decimal128::InvalidArgument < ::ArgumentError
  def message; end
end

BSON::Decimal128::InvalidArgument::MESSAGE = T.let(T.unsafe(nil), String)

class BSON::Decimal128::InvalidRange < ::RuntimeError
  def message; end
end

BSON::Decimal128::InvalidRange::MESSAGE = T.let(T.unsafe(nil), String)

class BSON::Decimal128::InvalidString < ::RuntimeError
  def message; end
end

BSON::Decimal128::InvalidString::MESSAGE = T.let(T.unsafe(nil), String)
BSON::Decimal128::MAX_DIGITS_OF_PRECISION = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::MAX_EXPONENT = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::MIN_EXPONENT = T.let(T.unsafe(nil), Integer)
BSON::Decimal128::NATIVE_TYPE = BigDecimal

class BSON::Document < ::Hash
  def initialize(elements = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def delete(key, &block); end
  def dig(*keys); end
  def except(*keys); end
  def fetch(key, *args, &block); end
  def has_key?(key); end
  def has_value?(value); end
  def include?(key); end
  def key?(key); end
  def member?(key); end
  def merge(other, &block); end
  def merge!(other); end
  def slice(*keys); end
  def symbolize_keys!; end
  def transform_keys; end
  def update(other); end
  def value(value); end

  private

  def convert_key(key); end
  def convert_value(value); end
end

module BSON::Environment
  extend ::BSON::Environment

  def jruby?; end
  def ruby_1_9?; end
end

class BSON::Error < ::StandardError; end
class BSON::Error::BSONDecodeError < ::BSON::Error; end
class BSON::Error::ExtJSONParseError < ::BSON::Error; end
class BSON::Error::UnserializableClass < ::BSON::Error; end
class BSON::Error::UnsupportedBinarySubtype < ::BSON::Error; end

module BSON::ExtJSON
  private

  def create_binary(encoded_value, encoded_subtype); end
  def create_regexp(pattern, options); end
  def map_hash(hash, **options); end
  def parse(str, **options); end
  def parse_hash(hash, **options); end
  def parse_obj(value, **options); end
  def verify_no_reserved_keys(hash, **options); end

  class << self
    def create_binary(encoded_value, encoded_subtype); end
    def create_regexp(pattern, options); end
    def map_hash(hash, **options); end
    def parse(str, **options); end
    def parse_hash(hash, **options); end
    def parse_obj(value, **options); end
    def verify_no_reserved_keys(hash, **options); end
  end
end

BSON::ExtJSON::RESERVED_KEYS = T.let(T.unsafe(nil), Array)
BSON::ExtJSON::RESERVED_KEYS_HASH = T.let(T.unsafe(nil), Hash)

module BSON::FalseClass
  def bson_type; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
end

BSON::FalseClass::FALSE_BYTE = T.let(T.unsafe(nil), String)

module BSON::Float
  def as_extended_json(**options); end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
end

BSON::Float::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Float::ClassMethods
  def from_bson(buffer, **options); end
end

BSON::Float::PACK = T.let(T.unsafe(nil), String)

module BSON::Hash
  def as_extended_json(**options); end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  def to_bson_normalized_value; end
end

BSON::Hash::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Hash::ClassMethods
  def from_bson(buffer, **options); end
end

class BSON::Int32
  def initialize(value); end

  def ==(other); end
  def ===(other); end
  def as_extended_json(**options); end
  def bson_type; end
  def eql?(other); end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  def to_bson_key(validating_keys = T.unsafe(nil)); end
  def value; end

  class << self
    def from_bson(buffer, **options); end
  end
end

BSON::Int32::BSON_TYPE = T.let(T.unsafe(nil), String)
BSON::Int32::BYTES_LENGTH = T.let(T.unsafe(nil), Integer)
BSON::Int32::PACK = T.let(T.unsafe(nil), String)

class BSON::Int64
  def initialize(value); end

  def ==(other); end
  def ===(other); end
  def as_extended_json(**options); end
  def bson_type; end
  def eql?(other); end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  def to_bson_key(validating_keys = T.unsafe(nil)); end
  def value; end

  class << self
    def from_bson(buffer, **options); end
  end
end

BSON::Int64::BSON_TYPE = T.let(T.unsafe(nil), String)
BSON::Int64::PACK = T.let(T.unsafe(nil), String)

module BSON::Integer
  def as_extended_json(**options); end
  def bson_int32?; end
  def bson_int64?; end
  def bson_type; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  def to_bson_int32(encoded); end
  def to_bson_int64(encoded); end
  def to_bson_key(validating_keys = T.unsafe(nil)); end

  private

  def append_bson_int32(encoded); end
  def out_of_range!; end
end

BSON::Integer::BSON_ARRAY_INDEXES = T.let(T.unsafe(nil), Array)
BSON::Integer::BSON_INDEX_SIZE = T.let(T.unsafe(nil), Integer)
BSON::Integer::MAX_32BIT = T.let(T.unsafe(nil), Integer)
BSON::Integer::MAX_64BIT = T.let(T.unsafe(nil), Integer)
BSON::Integer::MIN_32BIT = T.let(T.unsafe(nil), Integer)
BSON::Integer::MIN_64BIT = T.let(T.unsafe(nil), Integer)

class BSON::InvalidKey < ::RuntimeError
  def initialize(object); end
end

module BSON::JSON
  def to_json(*args); end
end

BSON::MILLISECONDS_IN_DAY = T.let(T.unsafe(nil), Integer)

class BSON::MaxKey
  include ::Comparable
  include ::BSON::JSON
  include ::BSON::Specialized
  extend ::BSON::Specialized::ClassMethods

  def <=>(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
end

BSON::MaxKey::BSON_TYPE = T.let(T.unsafe(nil), String)
BSON::MaxKey::GREATER = T.let(T.unsafe(nil), Integer)

class BSON::MinKey
  include ::Comparable
  include ::BSON::JSON
  include ::BSON::Specialized
  extend ::BSON::Specialized::ClassMethods

  def <=>(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
end

BSON::MinKey::BSON_TYPE = T.let(T.unsafe(nil), String)
BSON::MinKey::LESSER = T.let(T.unsafe(nil), Integer)
BSON::NO_VALUE = T.let(T.unsafe(nil), String)
BSON::NULL_BYTE = T.let(T.unsafe(nil), String)

module BSON::NilClass
  include ::BSON::Specialized
  extend ::BSON::Specialized::ClassMethods
end

BSON::NilClass::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::NilClass::ClassMethods
  def from_bson(buffer, **options); end
end

module BSON::Object
  def as_extended_json(**options); end
  def to_bson_key(validating_keys = T.unsafe(nil)); end
  def to_bson_normalized_key; end
  def to_bson_normalized_value; end
  def to_extended_json(**options); end
end

class BSON::ObjectId
  include ::Comparable
  include ::BSON::JSON

  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def as_extended_json(**options); end
  def as_json(options = T.unsafe(nil)); end
  def bson_type; end
  def eql?(other); end
  def generation_time; end
  def hash; end
  def inspect; end
  def marshal_dump; end
  def marshal_load(data); end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  def to_s; end
  def to_str; end
  def to_time; end

  private

  def generate_data; end
  def initialize_copy(other); end
  def repair; end

  class << self
    def from_bson(buffer, **options); end
    def from_data(data); end
    def from_string(string); end
    def from_time(time, options = T.unsafe(nil)); end
    def legal?(string); end
    def repair(object); end
  end
end

BSON::ObjectId::BSON_TYPE = T.let(T.unsafe(nil), String)

class BSON::ObjectId::Generator
  def initialize; end

  def generate(time, counter = T.unsafe(nil)); end
  def machine_id; end
  def next_object_id(*_arg0); end

  private

  def process_id; end
end

class BSON::ObjectId::Invalid < ::RuntimeError; end

module BSON::OpenStruct
  def bson_type; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
end

module BSON::Regexp
  include ::BSON::JSON

  def as_json(*args); end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end

  private

  def bson_dotall; end
  def bson_extended; end
  def bson_ignorecase; end
  def bson_options; end
end

BSON::Regexp::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Regexp::ClassMethods
  def from_bson(buffer, **opts); end
end

BSON::Regexp::EXTENDED_VALUE = T.let(T.unsafe(nil), String)
BSON::Regexp::IGNORECASE_VALUE = T.let(T.unsafe(nil), String)
BSON::Regexp::MULTILINE_VALUE = T.let(T.unsafe(nil), String)
BSON::Regexp::NEWLINE_VALUE = T.let(T.unsafe(nil), String)
BSON::Regexp::RUBY_MULTILINE_VALUE = T.let(T.unsafe(nil), String)

class BSON::Regexp::Raw
  include ::BSON::JSON

  def initialize(pattern, options = T.unsafe(nil)); end

  def ==(other); end
  def as_extended_json(**opts); end
  def as_json(*args); end
  def compile; end
  def eql?(other); end
  def options; end
  def pattern; end
  def respond_to?(method, include_private = T.unsafe(nil)); end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end

  private

  def method_missing(method, *arguments); end
  def options_to_int; end
end

module BSON::Registry
  extend ::BSON::Registry

  def get(byte, field = T.unsafe(nil)); end
  def register(byte, type); end

  private

  def define_type_reader(type); end
  def handle_unsupported_type!(byte, field); end
end

BSON::Registry::MAPPINGS = T.let(T.unsafe(nil), Hash)
class BSON::Registry::UnsupportedType < ::RuntimeError; end

module BSON::Specialized
  mixes_in_class_methods ::BSON::Specialized::ClassMethods

  def ==(other); end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end

  class << self
    def included(klass); end
  end
end

module BSON::Specialized::ClassMethods
  def from_bson(buffer, **options); end
end

module BSON::String
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  def to_bson_key(validating_keys = T.unsafe(nil)); end
  def to_bson_object_id; end
  def to_hex_string; end
end

BSON::String::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::String::ClassMethods
  def from_bson(buffer, **options); end
end

BSON::String::ILLEGAL_KEY = T.let(T.unsafe(nil), Regexp)

class BSON::String::IllegalKey < ::RuntimeError
  def initialize(string); end
end

module BSON::Symbol
  def as_extended_json(**options); end
  def bson_type; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  def to_bson_key(validating_keys = T.unsafe(nil)); end
  def to_bson_normalized_key; end
end

BSON::Symbol::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Symbol::ClassMethods
  def from_bson(buffer, **options); end
end

class BSON::Symbol::Raw
  def initialize(str_or_sym); end

  def ==(other); end
  def as_extended_json(**options); end
  def bson_type; end
  def eql?(other); end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  def to_s; end
  def to_sym; end
end

module BSON::Time
  def _bson_to_i; end
  def as_extended_json(**options); end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
end

BSON::Time::BSON_TYPE = T.let(T.unsafe(nil), String)

module BSON::Time::ClassMethods
  def from_bson(buffer, **options); end
end

module BSON::TimeWithZone
  def bson_type; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
end

class BSON::Timestamp
  include ::BSON::JSON
  include ::Comparable

  def initialize(seconds, increment); end

  def <=>(other); end
  def ==(other); end
  def as_extended_json(**options); end
  def as_json(*args); end
  def bson_type; end
  def increment; end
  def seconds; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end

  class << self
    def from_bson(buffer, **options); end
  end
end

BSON::Timestamp::BSON_TYPE = T.let(T.unsafe(nil), String)
BSON::Timestamp::COMPARISON_ERROR_MESSAGE = T.let(T.unsafe(nil), String)

module BSON::TrueClass
  def bson_type; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
end

BSON::TrueClass::TRUE_BYTE = T.let(T.unsafe(nil), String)
BSON::UTF8 = T.let(T.unsafe(nil), String)

class BSON::Undefined
  include ::BSON::Specialized
  extend ::BSON::Specialized::ClassMethods

  def ==(other); end
  def as_extended_json(**options); end
  def bson_type; end
end

BSON::Undefined::BSON_TYPE = T.let(T.unsafe(nil), String)
BSON::VERSION = T.let(T.unsafe(nil), String)
