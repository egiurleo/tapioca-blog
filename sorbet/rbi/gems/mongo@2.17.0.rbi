# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mongo` gem.
# Please instead update this file by running `bin/tapioca gem mongo`.

module Mongo
  private

  def clear_ocsp_cache; end
  def tls_context_hooks; end
  def tls_context_hooks=(hooks); end

  class << self
    def clear_ocsp_cache; end
    def tls_context_hooks; end
    def tls_context_hooks=(hooks); end
  end
end

class Mongo::Address
  extend ::Forwardable

  def initialize(seed, options = T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def host; end
  def inspect; end
  def options; end
  def port; end
  def seed; end
  def socket(socket_timeout, opts = T.unsafe(nil)); end
  def to_s; end

  private

  def map_exceptions; end
  def parse_host_port; end
end

Mongo::Address::FAMILY_MAP = T.let(T.unsafe(nil), Hash)

class Mongo::Address::IPv4
  def initialize(host, port, host_name = T.unsafe(nil)); end

  def host; end
  def host_name; end
  def port; end
  def socket(socket_timeout, options = T.unsafe(nil)); end

  class << self
    def parse(address); end
  end
end

Mongo::Address::IPv4::MATCH = T.let(T.unsafe(nil), Regexp)
Mongo::Address::IPv4::SPLIT = T.let(T.unsafe(nil), String)

class Mongo::Address::IPv6
  def initialize(host, port, host_name = T.unsafe(nil)); end

  def host; end
  def host_name; end
  def port; end
  def socket(socket_timeout, options = T.unsafe(nil)); end

  class << self
    def parse(address); end
  end
end

Mongo::Address::IPv6::MATCH = T.let(T.unsafe(nil), Regexp)
Mongo::Address::LOCALHOST = T.let(T.unsafe(nil), String)

class Mongo::Address::Unix
  def initialize(host, port = T.unsafe(nil), host_name = T.unsafe(nil)); end

  def host; end
  def port; end
  def socket(socket_timeout, options = T.unsafe(nil)); end

  class << self
    def parse(address); end
  end
end

Mongo::Address::Unix::MATCH = T.let(T.unsafe(nil), Regexp)

module Mongo::Address::Validator
  def validate_address_str!(address_str); end

  private

  def validate_hostname!(host); end
  def validate_port_str!(port); end
end

module Mongo::Auth
  extend ::Mongo::Auth

  def get(user, connection, **opts); end
end

class Mongo::Auth::Aws < ::Mongo::Auth::Base
  def login; end
end

class Mongo::Auth::Aws::Conversation < ::Mongo::Auth::SaslConversationBase
  def continue(reply_document, connection); end

  private

  def client_final_payload; end
  def client_first_data; end
  def client_first_payload; end
  def client_nonce; end
  def conversation_id; end
  def server_nonce; end
  def wrap_data(data); end
end

class Mongo::Auth::Aws::Credentials < ::Struct
  def access_key_id; end
  def access_key_id=(_); end
  def secret_access_key; end
  def secret_access_key=(_); end
  def session_token; end
  def session_token=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Mongo::Auth::Aws::CredentialsRetriever
  def initialize(user = T.unsafe(nil)); end

  def credentials; end
  def user; end

  private

  def credentials_valid?(credentials, source); end
  def ec2_metadata_credentials; end
  def ecs_metadata_credentials; end
  def http_get(http, uri, metadata_token); end
end

Mongo::Auth::Aws::CredentialsRetriever::METADATA_TIMEOUT = T.let(T.unsafe(nil), Integer)
Mongo::Auth::Aws::MECHANISM = T.let(T.unsafe(nil), String)

class Mongo::Auth::Aws::Request
  def initialize(access_key_id:, secret_access_key:, host:, server_nonce:, session_token: T.unsafe(nil), time: T.unsafe(nil)); end

  def access_key_id; end
  def authorization; end
  def canonical_request; end
  def formatted_date; end
  def formatted_time; end
  def headers; end
  def headers_to_sign; end
  def host; end
  def region; end
  def scope; end
  def secret_access_key; end
  def server_nonce; end
  def session_token; end
  def signature; end
  def signed_headers_string; end
  def time; end
  def validate!; end

  private

  def hmac(key, data); end
  def hmac_hex(key, data); end
end

Mongo::Auth::Aws::Request::STS_REQUEST_BODY = T.let(T.unsafe(nil), String)
Mongo::Auth::Aws::Request::VALIDATE_TIMEOUT = T.let(T.unsafe(nil), Integer)

class Mongo::Auth::Base
  def initialize(user, connection, **opts); end

  def connection; end
  def conversation; end
  def user; end

  private

  def converse_1_step(connection, conversation); end
  def converse_2_step(connection, conversation); end
  def converse_multi_step(connection, conversation, speculative_auth_result: T.unsafe(nil)); end
  def dispatch_msg(connection, conversation, msg); end
  def validate_reply!(connection, conversation, doc); end
end

class Mongo::Auth::CR < ::Mongo::Auth::Base
  def login; end
end

class Mongo::Auth::CR::Conversation < ::Mongo::Auth::ConversationBase
  def continue(reply_document, connection); end
  def database; end
  def nonce; end
  def start(connection); end
end

Mongo::Auth::CR::Conversation::LOGIN = T.let(T.unsafe(nil), Hash)
Mongo::Auth::CR::MECHANISM = T.let(T.unsafe(nil), String)

class Mongo::Auth::ConversationBase
  def initialize(user, connection, **opts); end

  def build_message(connection, auth_source, selector); end
  def connection; end
  def speculative_auth_document; end
  def user; end
  def validate_external_auth_source; end
end

module Mongo::Auth::CredentialCache
  private

  def cache(key); end
  def clear; end
  def get(key); end
  def set(key, value); end

  class << self
    def cache(key); end
    def clear; end
    def get(key); end
    def set(key, value); end
    def store; end
  end
end

Mongo::Auth::EXTERNAL = T.let(T.unsafe(nil), String)
Mongo::Auth::GET_NONCE = T.let(T.unsafe(nil), Hash)

class Mongo::Auth::Gssapi < ::Mongo::Auth::Base
  def login; end
end

class Mongo::Auth::Gssapi::Conversation < ::Mongo::Auth::SaslConversationBase
  def initialize(user, connection, **opts); end

  def authenticator; end
  def client_first_document; end
  def continue(reply_document, connection); end
  def finalize(connection); end
  def id; end
  def process_continue_response(reply_document); end
end

Mongo::Auth::Gssapi::Conversation::CONTINUE_MESSAGE = T.let(T.unsafe(nil), Hash)
Mongo::Auth::Gssapi::Conversation::START_MESSAGE = T.let(T.unsafe(nil), Hash)
Mongo::Auth::Gssapi::MECHANISM = T.let(T.unsafe(nil), String)
class Mongo::Auth::InvalidConfiguration < ::Mongo::Error::AuthError; end

class Mongo::Auth::InvalidMechanism < ::Mongo::Auth::InvalidConfiguration
  def initialize(mechanism); end
end

class Mongo::Auth::LDAP < ::Mongo::Auth::Base
  def login; end
end

class Mongo::Auth::LDAP::Conversation < ::Mongo::Auth::ConversationBase
  def start(connection); end

  private

  def payload; end
end

Mongo::Auth::LDAP::Conversation::LOGIN = T.let(T.unsafe(nil), Hash)
Mongo::Auth::LDAP::MECHANISM = T.let(T.unsafe(nil), String)
Mongo::Auth::NONCE = T.let(T.unsafe(nil), String)
module Mongo::Auth::Roles; end
Mongo::Auth::Roles::BACKUP = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::CLUSTER_ADMIN = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::CLUSTER_MANAGER = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::CLUSTER_MONITOR = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::DATABASE_ADMIN = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::DATABASE_ADMIN_ANY_DATABASE = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::DATABASE_OWNER = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::HOST_MANAGER = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::READ = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::READ_ANY_DATABASE = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::READ_WRITE = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::READ_WRITE_ANY_DATABASE = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::RESTORE = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::ROOT = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::USER_ADMIN = T.let(T.unsafe(nil), String)
Mongo::Auth::Roles::USER_ADMIN_ANY_DATABASE = T.let(T.unsafe(nil), String)
Mongo::Auth::SOURCES = T.let(T.unsafe(nil), Hash)

class Mongo::Auth::SaslConversationBase < ::Mongo::Auth::ConversationBase
  def start(connection); end

  private

  def auth_mechanism_name; end
  def client_first_document; end
  def client_first_message_options; end
  def validate_server_nonce!; end
end

Mongo::Auth::SaslConversationBase::CLIENT_CONTINUE_MESSAGE = T.let(T.unsafe(nil), Hash)
Mongo::Auth::SaslConversationBase::CLIENT_FIRST_MESSAGE = T.let(T.unsafe(nil), Hash)

class Mongo::Auth::Scram < ::Mongo::Auth::Base
  def initialize(user, connection, **opts); end

  def conversation; end
  def login; end
  def speculative_auth_client_nonce; end
  def speculative_auth_result; end
end

class Mongo::Auth::Scram256 < ::Mongo::Auth::Scram; end

class Mongo::Auth::Scram256::Conversation < ::Mongo::Auth::ScramConversationBase
  private

  def digest; end
  def hi(data); end
  def salted_password; end
end

Mongo::Auth::Scram256::MECHANISM = T.let(T.unsafe(nil), String)

class Mongo::Auth::Scram::Conversation < ::Mongo::Auth::ScramConversationBase
  private

  def digest; end
  def hi(data); end
  def salted_password; end
end

Mongo::Auth::Scram::MECHANISM = T.let(T.unsafe(nil), String)

class Mongo::Auth::ScramConversationBase < ::Mongo::Auth::SaslConversationBase
  def initialize(user, connection, client_nonce: T.unsafe(nil)); end

  def client_nonce; end
  def continue(reply_document, connection); end
  def finalize(connection); end
  def id; end
  def process_continue_response(reply_document); end
  def server_verified?; end
  def speculative_auth_document; end

  private

  def auth_message; end
  def cache_key(*extra); end
  def check_server_signature(payload_data); end
  def client_empty_message; end
  def client_final; end
  def client_final_message; end
  def client_first_message_options; end
  def client_first_payload; end
  def client_key; end
  def client_proof(key, signature); end
  def client_signature(key, message); end
  def compare_digest(a, b); end
  def first_bare; end
  def h(string); end
  def hmac(data, key); end
  def iterations; end
  def parse_payload(payload); end
  def payload_data; end
  def salt; end
  def server_key; end
  def server_nonce; end
  def server_signature; end
  def stored_key(key); end
  def without_proof; end
  def xor(first, second); end
end

Mongo::Auth::ScramConversationBase::MIN_ITER_COUNT = T.let(T.unsafe(nil), Integer)

module Mongo::Auth::StringPrep
  extend ::Mongo::Auth::StringPrep

  def prepare(data, mappings, prohibited, options = T.unsafe(nil)); end

  private

  def apply_maps(data, mappings); end
  def check_bidi!(out); end
  def check_prohibited!(out, prohibited); end
  def mapping(c, mappings); end
  def normalize!(out); end
  def table_contains?(table, c); end
end

module Mongo::Auth::StringPrep::Profiles; end
module Mongo::Auth::StringPrep::Profiles::SASL; end
Mongo::Auth::StringPrep::Profiles::SASL::MAPPINGS = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Profiles::SASL::MAP_NON_ASCII_TO_SPACE = T.let(T.unsafe(nil), Hash)
Mongo::Auth::StringPrep::Profiles::SASL::PROHIBITED = T.let(T.unsafe(nil), Array)
module Mongo::Auth::StringPrep::Tables; end
Mongo::Auth::StringPrep::Tables::A1 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::B1 = T.let(T.unsafe(nil), Hash)
Mongo::Auth::StringPrep::Tables::B2 = T.let(T.unsafe(nil), Hash)
Mongo::Auth::StringPrep::Tables::B3 = T.let(T.unsafe(nil), Hash)
Mongo::Auth::StringPrep::Tables::C1_1 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C1_2 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C2_1 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C2_2 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C3 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C4 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C5 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C6 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C7 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C8 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::C9 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::D1 = T.let(T.unsafe(nil), Array)
Mongo::Auth::StringPrep::Tables::D2 = T.let(T.unsafe(nil), Array)

class Mongo::Auth::Unauthorized < ::Mongo::Error::AuthError
  def initialize(user, used_mechanism: T.unsafe(nil), message: T.unsafe(nil), server: T.unsafe(nil)); end
end

class Mongo::Auth::User
  include ::Mongo::Loggable

  def initialize(options); end

  def ==(other); end
  def auth_key(nonce); end
  def auth_mech_properties; end
  def auth_source; end
  def database; end
  def encoded_name; end
  def hash; end
  def hashed_password; end
  def mechanism; end
  def name; end
  def options; end
  def password; end
  def roles; end
  def sasl_prepped_password; end
  def spec; end

  class << self
    def default_auth_source(options); end
  end
end

class Mongo::Auth::User::View
  extend ::Forwardable

  def initialize(database); end

  def client(*args, &block); end
  def cluster(*args, &block); end
  def create(user_or_name, options = T.unsafe(nil)); end
  def database; end
  def info(name, options = T.unsafe(nil)); end
  def next_primary(*args, &block); end
  def read_preference(*args, &block); end
  def remove(name, options = T.unsafe(nil)); end
  def update(user_or_name, options = T.unsafe(nil)); end

  private

  def execute_operation(options); end
  def generate(user, options); end
  def user_query(name, options = T.unsafe(nil)); end
end

class Mongo::Auth::X509 < ::Mongo::Auth::Base
  def initialize(user, connection, **opts); end

  def login; end
end

class Mongo::Auth::X509::Conversation < ::Mongo::Auth::ConversationBase
  def speculative_auth_document; end
  def start(connection); end

  private

  def client_first_document; end
end

Mongo::Auth::X509::Conversation::LOGIN = T.let(T.unsafe(nil), Hash)
Mongo::Auth::X509::MECHANISM = T.let(T.unsafe(nil), String)

module Mongo::BackgroundThread
  include ::Mongo::Loggable

  def run!; end
  def running?; end
  def stop!; end

  private

  def do_work; end
  def pre_stop; end
  def start!; end
  def wait_for_stop; end
end

class Mongo::BulkWrite
  include ::Mongo::Operation::ResponseHandling
  extend ::Forwardable

  def initialize(collection, requests, options = T.unsafe(nil)); end

  def client(*args, &block); end
  def cluster(*args, &block); end
  def collection; end
  def database(*args, &block); end
  def execute; end
  def next_primary(*args, &block); end
  def nro_write_with_retry(*args, &block); end
  def options; end
  def ordered?; end
  def requests; end
  def write_concern(session = T.unsafe(nil)); end
  def write_with_retry(*args, &block); end

  private

  def base_spec(operation_id, session); end
  def delete_many(documents, connection, context, operation_id, session, txn_num); end
  def delete_one(documents, connection, context, operation_id, session, txn_num); end
  def execute_operation(name, values, connection, context, operation_id, result_combiner, session, txn_num = T.unsafe(nil)); end
  def insert_one(documents, connection, context, operation_id, session, txn_num); end
  def op_combiner; end
  def replace_one(documents, connection, context, operation_id, session, txn_num); end
  def single_statement?(operation); end
  def split_execute(name, values, connection, context, operation_id, result_combiner, session, txn_num); end
  def update_many(documents, connection, context, operation_id, session, txn_num); end
  def update_one(documents, connection, context, operation_id, session, txn_num); end
  def validate_array_filters!(connection); end
  def validate_collation!(connection); end
  def validate_hint!(connection); end
end

module Mongo::BulkWrite::Combineable
  def initialize(requests); end

  def has_array_filters?; end
  def has_collation?; end
  def has_hint?; end
  def requests; end

  private

  def combine_requests(ops); end
end

class Mongo::BulkWrite::OrderedCombiner
  include ::Mongo::BulkWrite::Transformable
  include ::Mongo::BulkWrite::Validatable
  include ::Mongo::BulkWrite::Combineable

  def combine; end

  private

  def add(operations, name, document); end
  def next_group?(name, operations); end
end

class Mongo::BulkWrite::Result
  def initialize(results); end

  def deleted_count; end
  def inserted_count; end
  def inserted_ids; end
  def matched_count; end
  def modified_count; end
  def upserted_count; end
  def upserted_ids; end
  def validate!; end
end

Mongo::BulkWrite::Result::FIELDS = T.let(T.unsafe(nil), Array)
Mongo::BulkWrite::Result::INSERTED_COUNT = T.let(T.unsafe(nil), String)
Mongo::BulkWrite::Result::INSERTED_IDS = T.let(T.unsafe(nil), String)
Mongo::BulkWrite::Result::MATCHED_COUNT = T.let(T.unsafe(nil), String)
Mongo::BulkWrite::Result::MODIFIED_COUNT = T.let(T.unsafe(nil), String)
Mongo::BulkWrite::Result::REMOVED_COUNT = T.let(T.unsafe(nil), String)
Mongo::BulkWrite::Result::UPSERTED = T.let(T.unsafe(nil), String)
Mongo::BulkWrite::Result::UPSERTED_COUNT = T.let(T.unsafe(nil), String)
Mongo::BulkWrite::Result::UPSERTED_IDS = T.let(T.unsafe(nil), String)

class Mongo::BulkWrite::ResultCombiner
  def initialize; end

  def combine!(result, count); end
  def count; end
  def result; end
  def results; end

  private

  def combine_counts!(result); end
  def combine_errors!(result); end
  def combine_ids!(result); end
  def combine_write_concern_errors!(result); end
  def combine_write_errors!(result); end
end

Mongo::BulkWrite::SINGLE_STATEMENT_OPS = T.let(T.unsafe(nil), Array)

module Mongo::BulkWrite::Transformable
  private

  def transform(name, document); end
end

Mongo::BulkWrite::Transformable::DELETE_MANY = T.let(T.unsafe(nil), Symbol)
Mongo::BulkWrite::Transformable::DELETE_MANY_TRANSFORM = T.let(T.unsafe(nil), Proc)
Mongo::BulkWrite::Transformable::DELETE_ONE = T.let(T.unsafe(nil), Symbol)
Mongo::BulkWrite::Transformable::DELETE_ONE_TRANSFORM = T.let(T.unsafe(nil), Proc)
Mongo::BulkWrite::Transformable::INSERT_ONE = T.let(T.unsafe(nil), Symbol)
Mongo::BulkWrite::Transformable::INSERT_ONE_TRANSFORM = T.let(T.unsafe(nil), Proc)
Mongo::BulkWrite::Transformable::MAPPERS = T.let(T.unsafe(nil), Hash)
Mongo::BulkWrite::Transformable::REPLACE_ONE = T.let(T.unsafe(nil), Symbol)
Mongo::BulkWrite::Transformable::REPLACE_ONE_TRANSFORM = T.let(T.unsafe(nil), Proc)
Mongo::BulkWrite::Transformable::UPDATE_MANY = T.let(T.unsafe(nil), Symbol)
Mongo::BulkWrite::Transformable::UPDATE_MANY_TRANSFORM = T.let(T.unsafe(nil), Proc)
Mongo::BulkWrite::Transformable::UPDATE_ONE = T.let(T.unsafe(nil), Symbol)
Mongo::BulkWrite::Transformable::UPDATE_ONE_TRANSFORM = T.let(T.unsafe(nil), Proc)

class Mongo::BulkWrite::UnorderedCombiner
  include ::Mongo::BulkWrite::Transformable
  include ::Mongo::BulkWrite::Validatable
  include ::Mongo::BulkWrite::Combineable

  def combine; end

  private

  def add(operations, name, document); end
end

module Mongo::BulkWrite::Validatable
  def validate(name, document); end

  private

  def validate_document(name, document); end
  def validate_operation(name); end
end

class Mongo::CachingCursor < ::Mongo::Cursor
  def cached_docs; end
  def each; end
  def inspect; end
  def try_next; end
end

class Mongo::Client
  include ::Mongo::Loggable
  extend ::Forwardable

  def initialize(addresses_or_uri, options = T.unsafe(nil)); end

  def ==(other); end
  def [](collection_name, options = T.unsafe(nil)); end
  def close; end
  def close_encrypter; end
  def cluster; end
  def cluster_options; end
  def collections(*args, &block); end
  def command(*args, &block); end
  def database; end
  def database_names(filter = T.unsafe(nil), opts = T.unsafe(nil)); end
  def encrypter; end
  def eql?(other); end
  def get_session(options = T.unsafe(nil)); end
  def hash; end
  def inspect; end
  def list_databases(filter = T.unsafe(nil), name_only = T.unsafe(nil), opts = T.unsafe(nil)); end
  def list_mongo_databases(filter = T.unsafe(nil), opts = T.unsafe(nil)); end
  def max_read_retries; end
  def max_write_retries; end
  def options; end
  def read_concern; end
  def read_preference; end
  def read_retry_interval; end
  def reconnect; end
  def server_selector; end
  def start_session(options = T.unsafe(nil)); end
  def subscribe(*args, &block); end
  def summary; end
  def unsubscribe(*args, &block); end
  def update_options(new_options); end
  def use(name); end
  def watch(pipeline = T.unsafe(nil), options = T.unsafe(nil)); end
  def with(new_options = T.unsafe(nil)); end
  def with_session(options = T.unsafe(nil), &block); end
  def write_concern; end

  private

  def build_encrypter; end
  def cluster_modifying?(new_options); end
  def default_options(options); end
  def do_close; end
  def get_session!(options = T.unsafe(nil)); end
  def initialize_copy(original); end
  def monitoring; end
  def valid_compressors(compressors); end
  def validate_authentication_options!; end
  def validate_max_min_pool_size!(option, opts); end
  def validate_new_options!(opts); end
  def validate_options!(addresses = T.unsafe(nil)); end
  def validate_read!(option, opts); end
  def validate_snappy_compression!; end
  def validate_zstd_compression!; end

  class << self
    def canonicalize_ruby_options(options); end
  end
end

Mongo::Client::CRUD_OPTIONS = T.let(T.unsafe(nil), Array)
Mongo::Client::VALID_COMPRESSORS = T.let(T.unsafe(nil), Array)
Mongo::Client::VALID_OPTIONS = T.let(T.unsafe(nil), Array)
Mongo::Client::VALID_SERVER_API_VERSIONS = T.let(T.unsafe(nil), Array)

class Mongo::ClientEncryption
  def initialize(key_vault_client, options = T.unsafe(nil)); end

  def create_data_key(kms_provider, options = T.unsafe(nil)); end
  def decrypt(value); end
  def encrypt(value, options = T.unsafe(nil)); end
end

class Mongo::Cluster
  include ::Mongo::Loggable
  include ::Mongo::Monitoring::Publishable
  include ::Mongo::Event::Subscriber
  include ::Mongo::ClusterTime::Consumer
  extend ::Forwardable

  def initialize(seeds, monitoring, options = T.unsafe(nil)); end

  def ==(other); end
  def add(host, add_options = T.unsafe(nil)); end
  def addresses; end
  def app_metadata; end
  def connected?; end
  def connecting?; end
  def disconnect!; end
  def disconnect_server_if_connected(server); end
  def has_readable_server?(server_selector = T.unsafe(nil)); end
  def has_writable_server?; end
  def heartbeat_interval; end
  def inspect; end
  def load_balanced?; end
  def logical_session_timeout(*args, &block); end
  def max_read_retries; end
  def monitor_app_metadata; end
  def monitoring; end
  def next_primary(ping = T.unsafe(nil), session = T.unsafe(nil)); end
  def options; end
  def pool(server); end
  def push_monitor_app_metadata; end
  def read_retry_interval; end
  def reconnect!; end
  def register_cursor(*args); end
  def remove(host, disconnect: T.unsafe(nil)); end
  def replica_set?(*args, &block); end
  def replica_set_name(*args, &block); end
  def run_sdam_flow(previous_desc, updated_desc, options = T.unsafe(nil)); end
  def scan!(sync = T.unsafe(nil)); end
  def schedule_kill_cursor(*args); end
  def seeds; end
  def server_selection_semaphore; end
  def servers; end
  def servers_list; end
  def session_pool; end
  def set_server_list(server_address_strs); end
  def sharded?(*args, &block); end
  def single?(*args, &block); end
  def srv_monitor; end
  def summary; end
  def topology; end
  def unknown?(*args, &block); end
  def unregister_cursor(*args); end
  def update_cluster_time(result); end
  def update_topology(new_topology); end
  def validate_session_support!; end

  private

  def fabricate_lb_sdam_events_and_set_server_type; end
  def raise_sessions_not_supported; end
  def recreate_topology(new_topology_template, previous_topology); end
  def start_stop_srv_monitor; end

  class << self
    def create(client); end
  end
end

Mongo::Cluster::CLUSTER_TIME = T.let(T.unsafe(nil), String)

class Mongo::Cluster::CursorReaper
  include ::Mongo::Retryable

  def initialize(cluster); end

  def cluster; end
  def execute; end
  def flush; end
  def kill_cursors; end
  def register_cursor(id); end
  def schedule_kill_cursor(kill_spec, server); end
  def unregister_cursor(id); end
end

Mongo::Cluster::CursorReaper::FREQUENCY = T.let(T.unsafe(nil), Integer)
Mongo::Cluster::IDLE_WRITE_PERIOD_SECONDS = T.let(T.unsafe(nil), Integer)
Mongo::Cluster::MAX_READ_RETRIES = T.let(T.unsafe(nil), Integer)
Mongo::Cluster::MAX_WRITE_RETRIES = T.let(T.unsafe(nil), Integer)

class Mongo::Cluster::PeriodicExecutor
  include ::Mongo::Loggable
  include ::Mongo::BackgroundThread

  def initialize(executors, options = T.unsafe(nil)); end

  def do_work; end
  def execute; end
  def flush; end
  def options; end
  def pre_stop; end
  def restart!; end
  def stop(final = T.unsafe(nil)); end
end

Mongo::Cluster::PeriodicExecutor::FREQUENCY = T.let(T.unsafe(nil), Integer)
Mongo::Cluster::READ_RETRY_INTERVAL = T.let(T.unsafe(nil), Integer)

class Mongo::Cluster::SdamFlow
  extend ::Forwardable

  def initialize(cluster, previous_desc, updated_desc, awaited: T.unsafe(nil)); end

  def add_servers_from_desc(updated_desc); end
  def awaited?; end
  def became_unknown?; end
  def check_if_has_primary; end
  def cluster; end
  def commit_changes; end
  def disconnect_servers; end
  def do_remove(address_str); end
  def log_warn(*args, &block); end
  def original_desc; end
  def previous_desc; end
  def publish_description_change_event; end
  def publish_sdam_event(*args, &block); end
  def remove; end
  def remove_servers_not_in_desc(updated_desc); end
  def replica_set_name(*args, &block); end
  def seeds(*args, &block); end
  def server_description_changed; end
  def servers_list(*args, &block); end
  def stale_primary?; end
  def start_pool_if_data_bearing; end
  def topology; end
  def topology_effectively_changed?; end
  def update_rs_from_primary; end
  def update_rs_with_primary_from_member; end
  def update_rs_without_primary; end
  def update_server_descriptions; end
  def update_unknown_with_standalone; end
  def updated_desc; end
  def verify_invariants; end
end

class Mongo::Cluster::SocketReaper
  def initialize(cluster); end

  def execute; end
  def flush; end
end

module Mongo::Cluster::Topology
  extend ::Mongo::Cluster::Topology

  def initial(cluster, monitoring, options); end
end

class Mongo::Cluster::Topology::Base
  include ::Mongo::Loggable
  include ::Mongo::Monitoring::Publishable
  extend ::Forwardable

  def initialize(options, monitoring, cluster); end

  def addresses; end
  def compatibility_error; end
  def compatible?; end
  def data_bearing_servers?; end
  def logical_session_timeout; end
  def max_election_id; end
  def max_set_version; end
  def monitoring; end
  def new_max_election_id(description); end
  def new_max_set_version(description); end
  def options; end
  def replica_set_name; end
  def server_descriptions; end

  private

  def cluster; end
  def validate_options(options, cluster); end
end

class Mongo::Cluster::Topology::LoadBalanced < ::Mongo::Cluster::Topology::Base
  def display_name; end
  def has_readable_server?(cluster, server_selector = T.unsafe(nil)); end
  def has_writable_server?(cluster); end
  def replica_set?; end
  def servers(servers, name = T.unsafe(nil)); end
  def sharded?; end
  def single?; end
  def summary; end
  def unknown?; end

  private

  def validate_options(options, cluster); end
end

Mongo::Cluster::Topology::LoadBalanced::NAME = T.let(T.unsafe(nil), String)

module Mongo::Cluster::Topology::NoReplicaSetOptions
  private

  def validate_options(options, cluster); end
end

Mongo::Cluster::Topology::OPTIONS = T.let(T.unsafe(nil), Hash)

class Mongo::Cluster::Topology::ReplicaSetNoPrimary < ::Mongo::Cluster::Topology::Base
  def display_name; end
  def has_readable_server?(cluster, server_selector = T.unsafe(nil)); end
  def has_writable_server?(cluster); end
  def replica_set?; end
  def servers(servers); end
  def sharded?; end
  def single?; end
  def summary; end
  def unknown?; end

  private

  def validate_options(options, cluster); end
end

Mongo::Cluster::Topology::ReplicaSetNoPrimary::NAME = T.let(T.unsafe(nil), String)
class Mongo::Cluster::Topology::ReplicaSetWithPrimary < ::Mongo::Cluster::Topology::ReplicaSetNoPrimary; end

class Mongo::Cluster::Topology::Sharded < ::Mongo::Cluster::Topology::Base
  include ::Mongo::Cluster::Topology::NoReplicaSetOptions

  def display_name; end
  def has_readable_server?(cluster, server_selector = T.unsafe(nil)); end
  def has_writable_server?(cluster); end
  def replica_set?; end
  def servers(servers); end
  def sharded?; end
  def single?; end
  def summary; end
  def unknown?; end
end

Mongo::Cluster::Topology::Sharded::NAME = T.let(T.unsafe(nil), String)

class Mongo::Cluster::Topology::Single < ::Mongo::Cluster::Topology::Base
  def display_name; end
  def has_readable_server?(cluster, server_selector = T.unsafe(nil)); end
  def has_writable_server?(cluster); end
  def replica_set?; end
  def servers(servers, name = T.unsafe(nil)); end
  def sharded?; end
  def single?; end
  def summary; end
  def unknown?; end

  private

  def validate_options(options, cluster); end
end

Mongo::Cluster::Topology::Single::NAME = T.let(T.unsafe(nil), String)

class Mongo::Cluster::Topology::Unknown < ::Mongo::Cluster::Topology::Base
  include ::Mongo::Cluster::Topology::NoReplicaSetOptions

  def display_name; end
  def has_readable_server?(cluster, server_selector = T.unsafe(nil)); end
  def has_writable_server?(cluster); end
  def replica_set?; end
  def servers(servers); end
  def sharded?; end
  def single?; end
  def summary; end
  def unknown?; end
end

Mongo::Cluster::Topology::Unknown::NAME = T.let(T.unsafe(nil), String)

class Mongo::ClusterTime < ::BSON::Document
  def initialize(elements = T.unsafe(nil)); end

  def <(other); end
  def <=(other); end
  def <=>(other); end
  def ==(other); end
  def >(other); end
  def >=(other); end
  def advance(other); end

  class << self
    def [](doc); end
  end
end

module Mongo::ClusterTime::Consumer
  def advance_cluster_time(new_cluster_time); end
  def cluster_time; end
end

class Mongo::Collection
  include ::Mongo::Retryable
  extend ::Forwardable

  def initialize(database, name, options = T.unsafe(nil)); end

  def ==(other); end
  def aggregate(pipeline, options = T.unsafe(nil)); end
  def bulk_write(requests, options = T.unsafe(nil)); end
  def capped?; end
  def client(*args, &block); end
  def cluster(*args, &block); end
  def count(filter = T.unsafe(nil), options = T.unsafe(nil)); end
  def count_documents(filter = T.unsafe(nil), options = T.unsafe(nil)); end
  def create(opts = T.unsafe(nil)); end
  def database; end
  def delete_many(filter = T.unsafe(nil), options = T.unsafe(nil)); end
  def delete_one(filter = T.unsafe(nil), options = T.unsafe(nil)); end
  def distinct(field_name, filter = T.unsafe(nil), options = T.unsafe(nil)); end
  def drop(opts = T.unsafe(nil)); end
  def estimated_document_count(options = T.unsafe(nil)); end
  def find(filter = T.unsafe(nil), options = T.unsafe(nil)); end
  def find_one_and_delete(filter, options = T.unsafe(nil)); end
  def find_one_and_replace(filter, replacement, options = T.unsafe(nil)); end
  def find_one_and_update(filter, update, options = T.unsafe(nil)); end
  def indexes(options = T.unsafe(nil)); end
  def insert_many(documents, options = T.unsafe(nil)); end
  def insert_one(document, opts = T.unsafe(nil)); end
  def inspect; end
  def name; end
  def namespace; end
  def next_primary(*args, &block); end
  def options; end
  def parallel_scan(cursor_count, options = T.unsafe(nil)); end
  def read_concern; end
  def read_preference; end
  def replace_one(filter, replacement, options = T.unsafe(nil)); end
  def server_selector; end
  def system_collection?; end
  def update_many(filter, update, options = T.unsafe(nil)); end
  def update_one(filter, update, options = T.unsafe(nil)); end
  def watch(pipeline = T.unsafe(nil), options = T.unsafe(nil)); end
  def with(new_options); end
  def write_concern; end
  def write_concern_with_session(session); end
end

Mongo::Collection::CAPPED = T.let(T.unsafe(nil), String)
Mongo::Collection::CHANGEABLE_OPTIONS = T.let(T.unsafe(nil), Array)
Mongo::Collection::NS = T.let(T.unsafe(nil), String)
Mongo::Collection::TIME_SERIES_OPTIONS = T.let(T.unsafe(nil), Hash)

class Mongo::Collection::View
  include ::Enumerable
  include ::Mongo::Collection::View::Immutable
  include ::Mongo::Collection::View::Iterable
  include ::Mongo::Collection::View::Readable
  include ::Mongo::Collection::View::Explainable
  include ::Mongo::Collection::View::Writable
  extend ::Forwardable

  def initialize(collection, filter = T.unsafe(nil), options = T.unsafe(nil)); end

  def ==(other); end
  def client(*args, &block); end
  def cluster(*args, &block); end
  def collection; end
  def database(*args, &block); end
  def eql?(other); end
  def filter; end
  def hash; end
  def inspect; end
  def next_primary(*args, &block); end
  def nro_write_with_retry(*args, &block); end
  def read_with_retry(*args, &block); end
  def read_with_retry_cursor(*args, &block); end
  def selector; end
  def write_concern; end
  def write_concern_with_session(*args, &block); end
  def write_with_retry(*args, &block); end

  private

  def initialize_copy(other); end
  def new(options); end
  def view; end
  def with_session(opts = T.unsafe(nil), &block); end
end

class Mongo::Collection::View::Aggregation
  include ::Enumerable
  include ::Mongo::Collection::View::Immutable
  include ::Mongo::Collection::View::Iterable
  include ::Mongo::Collection::View::Explainable
  include ::Mongo::Loggable
  include ::Mongo::Retryable
  extend ::Forwardable

  def initialize(view, pipeline, options = T.unsafe(nil)); end

  def allow_disk_use(value = T.unsafe(nil)); end
  def client(*args, &block); end
  def cluster(*args, &block); end
  def collection(*args, &block); end
  def database(*args, &block); end
  def explain; end
  def pipeline; end
  def read(*args, &block); end
  def view; end
  def write?; end

  private

  def aggregate_spec(server, session, read_preference); end
  def cache_options; end
  def effective_read_preference(server); end
  def initial_query_op(server, session, read_preference); end
  def new(options); end
  def send_initial_query(server, session); end
  def server_selector; end
end

Mongo::Collection::View::Aggregation::REROUTE = T.let(T.unsafe(nil), String)
module Mongo::Collection::View::Builder; end

class Mongo::Collection::View::Builder::Aggregation
  extend ::Forwardable

  def initialize(pipeline, view, options); end

  def collection(*args, &block); end
  def database(*args, &block); end
  def options; end
  def pipeline; end
  def read(*args, &block); end
  def specification; end
  def view; end
  def write_concern(*args, &block); end

  private

  def aggregation_command; end
  def batch_size_doc; end
  def cursor; end
  def write?; end
end

Mongo::Collection::View::Builder::Aggregation::MAPPINGS = T.let(T.unsafe(nil), BSON::Document)

class Mongo::Collection::View::Builder::MapReduce
  extend ::Forwardable

  def initialize(map, reduce, view, options); end

  def collection(*args, &block); end
  def database(*args, &block); end
  def filter(*args, &block); end
  def map; end
  def options; end
  def read(*args, &block); end
  def reduce; end
  def specification; end
  def view; end
  def write_concern(*args, &block); end

  private

  def map_reduce_command; end
  def view_options; end
  def write?(spec); end
end

Mongo::Collection::View::Builder::MapReduce::MAPPINGS = T.let(T.unsafe(nil), BSON::Document)

class Mongo::Collection::View::ChangeStream < ::Mongo::Collection::View::Aggregation
  include ::Mongo::Collection::View::ChangeStream::Retryable

  def initialize(view, pipeline, changes_for, options = T.unsafe(nil)); end

  def close; end
  def closed?; end
  def each; end
  def inspect; end
  def options; end
  def resume_token; end
  def to_enum; end
  def try_next; end

  private

  def aggregate_spec(server, session, read_preference); end
  def change_doc; end
  def create_cursor!; end
  def for_cluster?; end
  def for_collection?; end
  def for_database?; end
  def pipeline; end
  def resuming?; end
  def send_initial_query(server, session); end
  def time_to_bson_timestamp(time); end
end

Mongo::Collection::View::ChangeStream::CLUSTER = T.let(T.unsafe(nil), Symbol)
Mongo::Collection::View::ChangeStream::DATABASE = T.let(T.unsafe(nil), Symbol)
Mongo::Collection::View::ChangeStream::FULL_DOCUMENT_DEFAULT = T.let(T.unsafe(nil), String)

module Mongo::Collection::View::ChangeStream::Retryable
  private

  def read_with_one_retry; end
end

module Mongo::Collection::View::Explainable
  def explain(**opts); end

  private

  def explain_options(**opts); end
  def explained?; end
end

Mongo::Collection::View::Explainable::ALL_PLANS_EXECUTION = T.let(T.unsafe(nil), String)
Mongo::Collection::View::Explainable::EXECUTION_STATS = T.let(T.unsafe(nil), String)
Mongo::Collection::View::Explainable::QUERY_PLANNER = T.let(T.unsafe(nil), String)

module Mongo::Collection::View::Immutable
  def options; end

  private

  def configure(field, value); end
end

module Mongo::Collection::View::Iterable
  def close_query; end
  def cursor; end
  def each; end
  def kill_cursors; end

  private

  def cache_options; end
  def cached_cursor; end
  def initial_query_op(server, session); end
  def select_cursor(session); end
  def send_initial_query(server, session = T.unsafe(nil)); end
  def use_query_cache?; end
end

class Mongo::Collection::View::MapReduce
  include ::Enumerable
  include ::Mongo::Collection::View::Immutable
  include ::Mongo::Loggable
  include ::Mongo::Retryable
  extend ::Forwardable

  def initialize(view, map, reduce, options = T.unsafe(nil)); end

  def client(*args, &block); end
  def cluster(*args, &block); end
  def collection(*args, &block); end
  def database(*args, &block); end
  def each; end
  def execute; end
  def finalize(function = T.unsafe(nil)); end
  def js_mode(value = T.unsafe(nil)); end
  def map_function; end
  def out(location = T.unsafe(nil)); end
  def out_collection_name; end
  def out_database_name; end
  def read(*args, &block); end
  def reduce_function; end
  def scope(object = T.unsafe(nil)); end
  def verbose(value = T.unsafe(nil)); end
  def view; end

  private

  def fetch_query_op(server, session); end
  def fetch_query_spec; end
  def find_command_spec(session); end
  def initial_query_op(session); end
  def inline?; end
  def map_reduce_spec(session = T.unsafe(nil)); end
  def new(options); end
  def secondary_ok?; end
  def send_fetch_query(server, session); end
  def send_initial_query(server, session); end
  def server_selector; end
  def valid_server?(server); end
end

Mongo::Collection::View::MapReduce::INLINE = T.let(T.unsafe(nil), String)
Mongo::Collection::View::MapReduce::OUT_ACTIONS = T.let(T.unsafe(nil), Array)
Mongo::Collection::View::MapReduce::REROUTE = T.let(T.unsafe(nil), String)

module Mongo::Collection::View::Readable
  def aggregate(pipeline, options = T.unsafe(nil)); end
  def allow_disk_use; end
  def allow_partial_results; end
  def await_data; end
  def batch_size(batch_size = T.unsafe(nil)); end
  def comment(comment = T.unsafe(nil)); end
  def count(opts = T.unsafe(nil)); end
  def count_documents(opts = T.unsafe(nil)); end
  def cursor_type(type = T.unsafe(nil)); end
  def distinct(field_name, opts = T.unsafe(nil)); end
  def estimated_document_count(opts = T.unsafe(nil)); end
  def hint(hint = T.unsafe(nil)); end
  def limit(limit = T.unsafe(nil)); end
  def map_reduce(map, reduce, options = T.unsafe(nil)); end
  def max_await_time_ms(max = T.unsafe(nil)); end
  def max_scan(value = T.unsafe(nil)); end
  def max_time_ms(max = T.unsafe(nil)); end
  def max_value(value = T.unsafe(nil)); end
  def min_value(value = T.unsafe(nil)); end
  def modifiers(doc = T.unsafe(nil)); end
  def no_cursor_timeout; end
  def projection(document = T.unsafe(nil)); end
  def read(value = T.unsafe(nil)); end
  def read_concern; end
  def read_preference; end
  def return_key(value = T.unsafe(nil)); end
  def show_disk_loc(value = T.unsafe(nil)); end
  def show_record_id(value = T.unsafe(nil)); end
  def skip(number = T.unsafe(nil)); end
  def snapshot(value = T.unsafe(nil)); end
  def sort(spec = T.unsafe(nil)); end

  private

  def collation(doc = T.unsafe(nil)); end
  def parallel_scan(cursor_count, options = T.unsafe(nil)); end
  def server_selector; end
  def validate_doc!(doc); end
end

module Mongo::Collection::View::Writable
  def delete_many(opts = T.unsafe(nil)); end
  def delete_one(opts = T.unsafe(nil)); end
  def find_one_and_delete(opts = T.unsafe(nil)); end
  def find_one_and_replace(replacement, opts = T.unsafe(nil)); end
  def find_one_and_update(document, opts = T.unsafe(nil)); end
  def replace_one(replacement, opts = T.unsafe(nil)); end
  def update_many(spec, opts = T.unsafe(nil)); end
  def update_one(spec, opts = T.unsafe(nil)); end
end

Mongo::Collection::View::Writable::ARRAY_FILTERS = T.let(T.unsafe(nil), String)
module Mongo::Crypt; end

class Mongo::Crypt::AutoDecryptionContext < ::Mongo::Crypt::Context
  def initialize(mongocrypt, io, command); end
end

class Mongo::Crypt::AutoEncrypter
  def initialize(options); end

  def close; end
  def decrypt(command); end
  def encrypt(database_name, command); end
  def encrypt?; end
  def key_vault_client; end
  def mongocryptd_client; end
  def options; end

  private

  def set_default_options(options); end
end

Mongo::Crypt::AutoEncrypter::DEFAULT_EXTRA_OPTIONS = T.let(T.unsafe(nil), Mongo::Options::Redacted)

class Mongo::Crypt::AutoEncryptionContext < ::Mongo::Crypt::Context
  def initialize(mongocrypt, io, db_name, command); end
end

class Mongo::Crypt::Binary
  def initialize(data: T.unsafe(nil), pointer: T.unsafe(nil)); end

  def ref; end
  def to_s; end
  def write(data); end

  class << self
    def from_data(data); end
    def from_pointer(pointer); end
    def wrap_string(str); end
  end
end

class Mongo::Crypt::Context
  def initialize(mongocrypt_handle, io); end

  def ctx_p; end
  def run_state_machine; end
  def state; end

  private

  def mongocrypt_done; end
  def mongocrypt_feed(doc); end
end

class Mongo::Crypt::DataKeyContext < ::Mongo::Crypt::Context
  def initialize(mongocrypt, io, kms_provider, options = T.unsafe(nil)); end

  private

  def initialize_ctx; end
  def set_aws_endpoint(endpoint); end
  def set_aws_master_key(master_key_opts); end
  def set_key_alt_names(key_alt_names); end
end

class Mongo::Crypt::EncryptionIO
  def initialize(key_vault_namespace:, key_vault_client:, client: T.unsafe(nil), mongocryptd_client: T.unsafe(nil), mongocryptd_options: T.unsafe(nil)); end

  def collection_info(db_name, filter); end
  def feed_kms(kms_context); end
  def find_keys(filter); end
  def insert_data_key(document); end
  def mark_command(cmd); end

  private

  def key_vault_collection; end
  def spawn_mongocryptd; end
  def validate_key_vault_client!(key_vault_client); end
  def validate_key_vault_namespace!(key_vault_namespace); end
  def with_ssl_socket(endpoint); end
end

Mongo::Crypt::EncryptionIO::SOCKET_TIMEOUT = T.let(T.unsafe(nil), Integer)

class Mongo::Crypt::ExplicitDecryptionContext < ::Mongo::Crypt::Context
  def initialize(mongocrypt, io, doc); end
end

class Mongo::Crypt::ExplicitEncrypter
  def initialize(key_vault_client, key_vault_namespace, kms_providers); end

  def create_and_insert_data_key(kms_provider, options); end
  def decrypt(value); end
  def encrypt(value, options); end
end

class Mongo::Crypt::ExplicitEncryptionContext < ::Mongo::Crypt::Context
  def initialize(mongocrypt, io, doc, options = T.unsafe(nil)); end
end

class Mongo::Crypt::Handle
  def initialize(kms_providers, options = T.unsafe(nil)); end

  def ref; end

  private

  def do_aes(key_binary_p, iv_binary_p, input_binary_p, output_binary_p, response_length_p, status_p, decrypt: T.unsafe(nil)); end
  def do_hmac_sha(digest_name, key_binary_p, input_binary_p, output_binary_p, status_p); end
  def handle_error(status_p); end
  def initialize_mongocrypt; end
  def set_crypto_hooks; end
  def set_kms_providers(kms_providers); end
  def set_kms_providers_aws(kms_providers); end
  def set_kms_providers_local(kms_providers); end
  def set_logger_callback; end
  def set_schema_map; end
  def write_binary_string_and_set_status(output_binary_p, status_p); end
end

module Mongo::Crypt::Hooks
  private

  def aes(key, iv, input, decrypt: T.unsafe(nil)); end
  def hash_sha256(input); end
  def hmac_sha(digest_name, key, input); end
  def random(num_bytes); end

  class << self
    def aes(key, iv, input, decrypt: T.unsafe(nil)); end
    def hash_sha256(input); end
    def hmac_sha(digest_name, key, input); end
    def random(num_bytes); end
  end
end

class Mongo::Crypt::KmsContext
  def initialize(kms_ctx); end

  def bytes_needed; end
  def endpoint; end
  def feed(data); end
  def kms_ctx_p; end
  def message; end
end

class Mongo::Crypt::Status
  def initialize(pointer: T.unsafe(nil)); end

  def code; end
  def label; end
  def message; end
  def ok?; end
  def raise_crypt_error; end
  def ref; end
  def update(label, code, message); end

  class << self
    def from_pointer(pointer); end
  end
end

class Mongo::Cursor
  include ::Enumerable
  include ::Mongo::Retryable
  extend ::Forwardable

  def initialize(view, result, server, options = T.unsafe(nil)); end

  def batch_size; end
  def client(*args, &block); end
  def close; end
  def closed?; end
  def cluster(*args, &block); end
  def collection(*args, &block); end
  def collection_name; end
  def database(*args, &block); end
  def each; end
  def fully_iterated?; end
  def get_more; end
  def id; end
  def initial_result; end
  def inspect; end
  def kill_spec; end
  def resume_token; end
  def server; end
  def to_return; end
  def try_next; end
  def view; end

  private

  def cache_batch_resume_token; end
  def cache_resume_token(doc); end
  def end_session; end
  def execute_operation(op); end
  def exhausted?; end
  def get_more_operation; end
  def limit; end
  def limited?; end
  def process(result); end
  def register; end
  def unregister; end
  def use_limit?; end

  class << self
    def finalize(kill_spec, cluster, server, session); end
  end
end

class Mongo::Cursor::KillSpec
  def initialize(cursor_id:, coll_name:, db_name:, service_id:); end

  def coll_name; end
  def cursor_id; end
  def db_name; end
  def service_id; end
end

class Mongo::DBRef
  include ::BSON::JSON

  def initialize(collection, id, database = T.unsafe(nil)); end

  def as_json(*args); end
  def collection; end
  def database; end
  def id; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
end

Mongo::DBRef::COLLECTION = T.let(T.unsafe(nil), String)

module Mongo::DBRef::ClassMethods
  def from_bson(buffer, **options); end
end

Mongo::DBRef::DATABASE = T.let(T.unsafe(nil), String)
Mongo::DBRef::ID = T.let(T.unsafe(nil), String)

class Mongo::Database
  include ::Mongo::Retryable
  extend ::Forwardable

  def initialize(client, name, options = T.unsafe(nil)); end

  def ==(other); end
  def [](collection_name, options = T.unsafe(nil)); end
  def aggregate(pipeline, options = T.unsafe(nil)); end
  def client; end
  def cluster(*args, &block); end
  def collection(collection_name, options = T.unsafe(nil)); end
  def collection_names(options = T.unsafe(nil)); end
  def collections(options = T.unsafe(nil)); end
  def command(operation, opts = T.unsafe(nil)); end
  def drop(options = T.unsafe(nil)); end
  def fs(options = T.unsafe(nil)); end
  def inspect; end
  def list_collections(options = T.unsafe(nil)); end
  def name; end
  def next_primary(*args, &block); end
  def options; end
  def read_command(operation, opts = T.unsafe(nil)); end
  def read_concern(*args, &block); end
  def read_preference(*args, &block); end
  def server_selector(*args, &block); end
  def users; end
  def watch(pipeline = T.unsafe(nil), options = T.unsafe(nil)); end
  def write_concern(*args, &block); end

  class << self
    def create(client); end
  end
end

Mongo::Database::ADMIN = T.let(T.unsafe(nil), String)
Mongo::Database::COMMAND = T.let(T.unsafe(nil), String)
Mongo::Database::DATABASES = T.let(T.unsafe(nil), String)
Mongo::Database::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Mongo::Options::Redacted)
Mongo::Database::NAME = T.let(T.unsafe(nil), String)
Mongo::Database::NAMESPACES = T.let(T.unsafe(nil), String)

class Mongo::Database::View
  include ::Enumerable
  include ::Mongo::Retryable
  extend ::Forwardable

  def initialize(database); end

  def aggregate(pipeline, options = T.unsafe(nil)); end
  def batch_size; end
  def client(*args, &block); end
  def cluster(*args, &block); end
  def collection; end
  def collection_names(options = T.unsafe(nil)); end
  def database; end
  def limit; end
  def list_collections(options = T.unsafe(nil)); end
  def next_primary(*args, &block); end
  def read_concern(*args, &block); end
  def read_preference(*args, &block); end
  def server_selector(*args, &block); end
  def write_concern(*args, &block); end

  private

  def collections_info(session, server_selector, options = T.unsafe(nil), &block); end
  def collections_info_spec(session, options = T.unsafe(nil)); end
  def initial_query_op(session, options = T.unsafe(nil)); end
  def send_initial_query(server, session, options = T.unsafe(nil)); end
end

class Mongo::DistinguishingSemaphore
  def initialize; end

  def broadcast; end
  def signal; end
  def wait(timeout = T.unsafe(nil)); end
end

class Mongo::Error < ::StandardError
  include ::Mongo::Error::Notable

  def initialize(msg = T.unsafe(nil)); end

  def add_label(label); end
  def change_stream_resumable?; end
  def label?(label); end
  def labels; end
  def write_concern_error_label?(label); end
  def write_concern_error_labels; end
end

class Mongo::Error::AuthError < ::RuntimeError
  include ::Mongo::Error::Notable
end

Mongo::Error::BAD_VALUE = T.let(T.unsafe(nil), Integer)
class Mongo::Error::BadLoadBalancerTarget < ::Mongo::Error; end

class Mongo::Error::BulkWriteError < ::Mongo::Error
  def initialize(result); end

  def result; end

  private

  def build_message; end
end

Mongo::Error::CODE = T.let(T.unsafe(nil), String)
Mongo::Error::CURSOR_NOT_FOUND = T.let(T.unsafe(nil), String)

module Mongo::Error::ChangeStreamResumable
  def change_stream_resumable?; end
end

class Mongo::Error::ClosedStream < ::Mongo::Error
  def initialize; end
end

class Mongo::Error::ConnectionCheckOutTimeout < ::Timeout::Error
  def initialize(msg, options); end

  def address; end
end

class Mongo::Error::ConnectionPerished < ::Mongo::Error; end
class Mongo::Error::CredentialCheckError < ::Mongo::Error::AuthError; end

class Mongo::Error::CryptError < ::Mongo::Error
  def initialize(message, code: T.unsafe(nil)); end
end

Mongo::Error::ERR = T.let(T.unsafe(nil), String)
Mongo::Error::ERRMSG = T.let(T.unsafe(nil), String)
Mongo::Error::ERROR = T.let(T.unsafe(nil), String)

class Mongo::Error::ExtraFileChunk < ::Mongo::Error
  def initialize; end
end

class Mongo::Error::FailedStringPrepValidation < ::Mongo::Error
  def initialize(msg); end
end

Mongo::Error::FailedStringPrepValidation::INVALID_BIDIRECTIONAL = T.let(T.unsafe(nil), String)
Mongo::Error::FailedStringPrepValidation::PROHIBITED_CHARACTER = T.let(T.unsafe(nil), String)
Mongo::Error::FailedStringPrepValidation::UNABLE_TO_NORMALIZE = T.let(T.unsafe(nil), String)

class Mongo::Error::FileNotFound < ::Mongo::Error
  def initialize(value, property); end
end

class Mongo::Error::HandshakeError < ::Mongo::Error; end

class Mongo::Error::InsufficientIterationCount < ::Mongo::Error
  def initialize(msg); end

  class << self
    def message(required_count, given_count); end
  end
end

class Mongo::Error::InternalDriverError < ::Mongo::Error; end
class Mongo::Error::InvalidAddress < ::Mongo::Error; end

class Mongo::Error::InvalidApplicationName < ::Mongo::Error
  def initialize(app_name, max_size); end
end

class Mongo::Error::InvalidBulkOperation < ::Mongo::Error
  def initialize(type, operation); end
end

class Mongo::Error::InvalidBulkOperationType < ::Mongo::Error
  def initialize(type); end
end

class Mongo::Error::InvalidCollectionName < ::Mongo::Error
  def initialize; end
end

Mongo::Error::InvalidCollectionName::MESSAGE = T.let(T.unsafe(nil), String)
class Mongo::Error::InvalidCursorOperation < ::Mongo::Error; end

class Mongo::Error::InvalidDatabaseName < ::Mongo::Error
  def initialize; end
end

Mongo::Error::InvalidDatabaseName::MESSAGE = T.let(T.unsafe(nil), String)

class Mongo::Error::InvalidDocument < ::Mongo::Error
  def initialize; end
end

Mongo::Error::InvalidDocument::MESSAGE = T.let(T.unsafe(nil), String)

class Mongo::Error::InvalidFile < ::Mongo::Error
  def initialize(client_md5, server_md5); end
end

class Mongo::Error::InvalidFileRevision < ::Mongo::Error
  def initialize(filename, revision); end
end

class Mongo::Error::InvalidMinPoolSize < ::Mongo::Error
  def initialize(min, max); end
end

class Mongo::Error::InvalidNonce < ::Mongo::Error
  def initialize(nonce, rnonce); end

  def nonce; end
  def rnonce; end
end

class Mongo::Error::InvalidReadConcern < ::Mongo::Error
  def initialize(msg = T.unsafe(nil)); end
end

class Mongo::Error::InvalidReadOption < ::Mongo::Error
  def initialize(read_option, msg); end
end

class Mongo::Error::InvalidReplacementDocument < ::Mongo::Error
  def initialize; end
end

Mongo::Error::InvalidReplacementDocument::MESSAGE = T.let(T.unsafe(nil), String)
class Mongo::Error::InvalidServerAuthHost < ::Mongo::Error::InvalidServerAuthResponse; end
class Mongo::Error::InvalidServerAuthResponse < ::Mongo::Error::AuthError; end

class Mongo::Error::InvalidServerPreference < ::Mongo::Error
  def initialize(message); end
end

Mongo::Error::InvalidServerPreference::INVALID_MAX_STALENESS = T.let(T.unsafe(nil), String)
Mongo::Error::InvalidServerPreference::NO_HEDGE_SUPPORT = T.let(T.unsafe(nil), String)
Mongo::Error::InvalidServerPreference::NO_MAX_STALENESS_SUPPORT = T.let(T.unsafe(nil), String)
Mongo::Error::InvalidServerPreference::NO_MAX_STALENESS_WITH_LEGACY_SERVER = T.let(T.unsafe(nil), String)
Mongo::Error::InvalidServerPreference::NO_TAG_SUPPORT = T.let(T.unsafe(nil), String)

class Mongo::Error::InvalidSession < ::Mongo::Error
  def initialize(message); end
end

class Mongo::Error::InvalidSignature < ::Mongo::Error
  def initialize(verifier, server_signature); end

  def server_signature; end
  def verifier; end
end

class Mongo::Error::InvalidTXTRecord < ::Mongo::Error; end

class Mongo::Error::InvalidTransactionOperation < ::Mongo::Error
  def initialize(msg); end

  class << self
    def cannot_call_after_msg(last_op, current_op); end
    def cannot_call_twice_msg(op); end
  end
end

Mongo::Error::InvalidTransactionOperation::INVALID_READ_PREFERENCE = T.let(T.unsafe(nil), String)
Mongo::Error::InvalidTransactionOperation::NO_TRANSACTION_STARTED = T.let(T.unsafe(nil), String)
Mongo::Error::InvalidTransactionOperation::TRANSACTION_ALREADY_IN_PROGRESS = T.let(T.unsafe(nil), String)
Mongo::Error::InvalidTransactionOperation::UNACKNOWLEDGED_WRITE_CONCERN = T.let(T.unsafe(nil), String)

class Mongo::Error::InvalidURI < ::Mongo::Error
  def initialize(uri, details, format = T.unsafe(nil)); end
end

class Mongo::Error::InvalidUpdateDocument < ::Mongo::Error
  def initialize; end
end

Mongo::Error::InvalidUpdateDocument::MESSAGE = T.let(T.unsafe(nil), String)

class Mongo::Error::InvalidWriteConcern < ::Mongo::Error
  def initialize(msg = T.unsafe(nil)); end
end

class Mongo::Error::KmsError < ::Mongo::Error::CryptError; end
class Mongo::Error::LintError < ::Mongo::Error; end

class Mongo::Error::MaxBSONSize < ::Mongo::Error
  def initialize(max_size_or_msg = T.unsafe(nil)); end
end

Mongo::Error::MaxBSONSize::MESSAGE = T.let(T.unsafe(nil), String)

class Mongo::Error::MaxMessageSize < ::Mongo::Error
  def initialize(max_size = T.unsafe(nil)); end
end

Mongo::Error::MaxMessageSize::MESSAGE = T.let(T.unsafe(nil), String)
class Mongo::Error::MismatchedDomain < ::Mongo::Error; end

class Mongo::Error::MissingFileChunk < ::Mongo::Error
  def initialize(expected_n, chunk); end
end

class Mongo::Error::MissingPassword < ::Mongo::Error
  def initialize(msg = T.unsafe(nil)); end
end

class Mongo::Error::MissingResumeToken < ::Mongo::Error
  def initialize; end
end

Mongo::Error::MissingResumeToken::MESSAGE = T.let(T.unsafe(nil), String)

class Mongo::Error::MissingScramServerSignature < ::Mongo::Error
  def initialize(msg = T.unsafe(nil)); end
end

class Mongo::Error::MissingServiceId < ::Mongo::Error; end
class Mongo::Error::MongocryptdSpawnError < ::Mongo::Error::CryptError; end

class Mongo::Error::MultiIndexDrop < ::Mongo::Error
  def initialize; end
end

class Mongo::Error::NeedPrimaryServer < ::Mongo::Error; end
class Mongo::Error::NoSRVRecords < ::Mongo::Error; end

class Mongo::Error::NoServerAvailable < ::Mongo::Error
  def initialize(server_selector, cluster = T.unsafe(nil), msg = T.unsafe(nil)); end
end

class Mongo::Error::NoServiceConnectionAvailable < ::Mongo::Error
  def initialize(message, address:, service_id:); end

  def address; end
  def service_id; end

  class << self
    def generate(address:, service_id:); end
  end
end

module Mongo::Error::Notable
  def add_note(note); end
  def generation; end
  def generation=(_arg0); end
  def notes; end
  def service_id; end
  def service_id=(_arg0); end
  def to_s; end

  private

  def notes_tail; end
end

class Mongo::Error::OperationFailure < ::Mongo::Error
  include ::Mongo::Error::SdamErrorDetection
  extend ::Forwardable

  def initialize(message = T.unsafe(nil), result = T.unsafe(nil), options = T.unsafe(nil)); end

  def change_stream_resumable?; end
  def code; end
  def code_name; end
  def connection_description(*args, &block); end
  def document; end
  def max_time_ms_expired?; end
  def operation_time(*args, &block); end
  def retryable?; end
  def server_message; end
  def unsupported_retryable_write?; end
  def write_concern_error?; end
  def write_concern_error_code; end
  def write_concern_error_code_name; end
  def write_concern_error_document; end
  def write_retryable?; end
  def wtimeout?; end

  private

  def change_stream_resumable_code?; end
  def write_retryable_code?; end
end

Mongo::Error::OperationFailure::CHANGE_STREAM_RESUME_ERRORS = T.let(T.unsafe(nil), Array)
Mongo::Error::OperationFailure::CHANGE_STREAM_RESUME_MESSAGES = T.let(T.unsafe(nil), Array)
Mongo::Error::OperationFailure::RETRY_MESSAGES = T.let(T.unsafe(nil), Array)
Mongo::Error::OperationFailure::WRITE_RETRY_ERRORS = T.let(T.unsafe(nil), Array)
Mongo::Error::OperationFailure::WRITE_RETRY_MESSAGES = T.let(T.unsafe(nil), Array)

class Mongo::Error::Parser
  include ::Mongo::Error::SdamErrorDetection

  def initialize(document, replies = T.unsafe(nil), options = T.unsafe(nil)); end

  def code; end
  def code_name; end
  def document; end
  def labels; end
  def message; end
  def replies; end
  def server_message; end
  def write_concern_error?; end
  def write_concern_error_code; end
  def write_concern_error_code_name; end
  def write_concern_error_document; end
  def write_concern_error_labels; end
  def wtimeout; end

  private

  def append(message, error); end
  def parse!; end
  def parse_code; end
  def parse_flag(message); end
  def parse_labels; end
  def parse_multiple(message, key); end
  def parse_single(message, key, doc = T.unsafe(nil)); end
  def parse_wtimeout; end

  class << self
    def build_message(code: T.unsafe(nil), code_name: T.unsafe(nil), message: T.unsafe(nil)); end
  end
end

class Mongo::Error::PoolClosedError < ::Mongo::Error
  def initialize(address, pool); end

  def address; end
  def pool; end
end

class Mongo::Error::RaiseOriginalError < ::Exception; end

module Mongo::Error::SdamErrorDetection
  def node_recovering?; end
  def node_shutting_down?; end
  def not_master?; end
end

Mongo::Error::SdamErrorDetection::NODE_RECOVERING_CODES = T.let(T.unsafe(nil), Array)
Mongo::Error::SdamErrorDetection::NODE_SHUTTING_DOWN_CODES = T.let(T.unsafe(nil), Array)
Mongo::Error::SdamErrorDetection::NOT_MASTER_CODES = T.let(T.unsafe(nil), Array)
class Mongo::Error::ServerApiConflict < ::Mongo::Error; end
class Mongo::Error::ServerApiNotSupported < ::Mongo::Error; end
class Mongo::Error::ServerCertificateRevoked < ::Mongo::Error; end

class Mongo::Error::SessionEnded < ::Mongo::Error
  def initialize; end
end

class Mongo::Error::SessionsNotSupported < ::Mongo::Error::InvalidSession
  def initialize(message); end
end

class Mongo::Error::SnapshotSessionInvalidServerVersion < ::Mongo::Error
  def initialize; end
end

class Mongo::Error::SnapshotSessionTransactionProhibited < ::Mongo::Error
  def initialize; end
end

class Mongo::Error::SocketError < ::Mongo::Error
  include ::Mongo::Error::WriteRetryable
  include ::Mongo::Error::ChangeStreamResumable
end

class Mongo::Error::SocketTimeoutError < ::Mongo::Error
  include ::Mongo::Error::WriteRetryable
  include ::Mongo::Error::ChangeStreamResumable
end

Mongo::Error::TRANSIENT_TRANSACTION_ERROR_LABEL = T.let(T.unsafe(nil), String)
Mongo::Error::UNKNOWN_ERROR = T.let(T.unsafe(nil), Integer)
Mongo::Error::UNKNOWN_TRANSACTION_COMMIT_RESULT_LABEL = T.let(T.unsafe(nil), String)

class Mongo::Error::UnchangeableCollectionOption < ::Mongo::Error
  def initialize(option); end
end

class Mongo::Error::UnexpectedChunkLength < ::Mongo::Error
  def initialize(expected_len, chunk); end
end

class Mongo::Error::UnexpectedResponse < ::Mongo::Error
  def initialize(expected_response_to, response_to); end
end

class Mongo::Error::UnknownPayloadType < ::Mongo::Error
  def initialize(byte); end
end

Mongo::Error::UnknownPayloadType::MESSAGE = T.let(T.unsafe(nil), String)
class Mongo::Error::UnmetDependency < ::Mongo::Error; end

class Mongo::Error::UnsupportedArrayFilters < ::Mongo::Error::UnsupportedOption
  def initialize(message = T.unsafe(nil)); end
end

Mongo::Error::UnsupportedArrayFilters::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Error::UnsupportedArrayFilters::UNACKNOWLEDGED_WRITES_MESSAGE = T.let(T.unsafe(nil), String)

class Mongo::Error::UnsupportedCollation < ::Mongo::Error::UnsupportedOption
  def initialize(message = T.unsafe(nil)); end
end

Mongo::Error::UnsupportedCollation::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Error::UnsupportedCollation::UNACKNOWLEDGED_WRITES_MESSAGE = T.let(T.unsafe(nil), String)
class Mongo::Error::UnsupportedFeatures < ::Mongo::Error; end
class Mongo::Error::UnsupportedMessageType < ::Mongo::Error; end

class Mongo::Error::UnsupportedOption < ::Mongo::Error
  class << self
    def allow_disk_use_error; end
    def commit_quorum_error; end
    def hint_error(**options); end
  end
end

Mongo::Error::UnsupportedOption::ALLOW_DISK_USE_MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Error::UnsupportedOption::COMMIT_QUORUM_MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Error::UnsupportedOption::HINT_MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Error::UnsupportedOption::UNACKNOWLEDGED_HINT_MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Error::WRITE_CONCERN_ERROR = T.let(T.unsafe(nil), String)
Mongo::Error::WRITE_CONCERN_ERRORS = T.let(T.unsafe(nil), String)
Mongo::Error::WRITE_ERRORS = T.let(T.unsafe(nil), String)

module Mongo::Error::WriteRetryable
  def write_retryable?; end
end

module Mongo::Event; end

class Mongo::Event::Base
  def summary; end

  private

  def short_class_name; end
end

Mongo::Event::DESCRIPTION_CHANGED = T.let(T.unsafe(nil), String)

class Mongo::Event::Listeners
  def initialize; end

  def add_listener(event, listener); end
  def listeners_for(event); end
end

Mongo::Event::MEMBER_DISCOVERED = T.let(T.unsafe(nil), String)
Mongo::Event::PRIMARY_ELECTED = T.let(T.unsafe(nil), String)

module Mongo::Event::Publisher
  def event_listeners; end
  def publish(event, *args); end
end

Mongo::Event::STANDALONE_DISCOVERED = T.let(T.unsafe(nil), String)

module Mongo::Event::Subscriber
  def event_listeners; end
  def subscribe_to(event, listener); end
end

module Mongo::Grid; end

class Mongo::Grid::FSBucket
  extend ::Forwardable

  def initialize(database, options = T.unsafe(nil)); end

  def chunks_collection; end
  def client(*args, &block); end
  def database; end
  def delete(id); end
  def delete_one(file); end
  def download_to_stream(id, io); end
  def download_to_stream_by_name(filename, io, opts = T.unsafe(nil)); end
  def files_collection; end
  def find(selector = T.unsafe(nil), options = T.unsafe(nil)); end
  def find_one(selector = T.unsafe(nil)); end
  def insert_one(file); end
  def open_download_stream(id, options = T.unsafe(nil)); end
  def open_download_stream_by_name(filename, opts = T.unsafe(nil), &block); end
  def open_upload_stream(filename, opts = T.unsafe(nil)); end
  def options; end
  def prefix; end
  def read_preference; end
  def upload_from_stream(filename, io, opts = T.unsafe(nil)); end
  def write_concern; end

  private

  def chunks_name; end
  def create_index_if_missing!(collection, index_spec, options = T.unsafe(nil)); end
  def ensure_indexes!; end
  def files_name; end
  def read_stream(id, **opts); end
  def write_stream(filename, **opts); end
end

Mongo::Grid::FSBucket::CHUNKS_INDEX = T.let(T.unsafe(nil), Hash)
Mongo::Grid::FSBucket::DEFAULT_ROOT = T.let(T.unsafe(nil), String)
Mongo::Grid::FSBucket::FILES_INDEX = T.let(T.unsafe(nil), Hash)

module Mongo::Grid::FSBucket::Stream
  extend ::Mongo::Grid::FSBucket::Stream

  def get(fs, mode, options = T.unsafe(nil)); end
end

Mongo::Grid::FSBucket::Stream::MODE_MAP = T.let(T.unsafe(nil), Hash)
Mongo::Grid::FSBucket::Stream::READ_MODE = T.let(T.unsafe(nil), Symbol)

class Mongo::Grid::FSBucket::Stream::Read
  include ::Enumerable

  def initialize(fs, options); end

  def close; end
  def closed?; end
  def each; end
  def file_id; end
  def file_info; end
  def fs; end
  def options; end
  def read; end
  def read_preference; end

  private

  def ensure_file_info!; end
  def ensure_open!; end
  def ensure_readable!; end
  def raise_unexpected_chunk_length!(chunk); end
  def validate!(index, num_chunks, chunk, length_read); end
  def validate_length!(index, num_chunks, chunk, length_read); end
  def validate_n!(index, chunk); end
  def view; end
end

Mongo::Grid::FSBucket::Stream::WRITE_MODE = T.let(T.unsafe(nil), Symbol)

class Mongo::Grid::FSBucket::Stream::Write
  def initialize(fs, options); end

  def abort; end
  def close; end
  def closed?; end
  def file_id; end
  def filename; end
  def fs; end
  def options; end
  def write(io); end
  def write_concern; end

  private

  def chunks_collection; end
  def ensure_indexes!; end
  def ensure_open!; end
  def file_info; end
  def files_collection; end
  def update_length; end
  def with_write_concern(collection); end
end

class Mongo::Grid::File
  extend ::Forwardable

  def initialize(data, options = T.unsafe(nil)); end

  def ==(other); end
  def chunk_size(*args, &block); end
  def chunks; end
  def content_type(*args, &block); end
  def data; end
  def filename(*args, &block); end
  def id(*args, &block); end
  def info; end
  def inspect; end
  def md5(*args, &block); end
  def upload_date(*args, &block); end

  private

  def initialize_chunks!(value); end
end

class Mongo::Grid::File::Chunk
  def initialize(document); end

  def ==(other); end
  def bson_type; end
  def data; end
  def document; end
  def files_id; end
  def id; end
  def n; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end

  class << self
    def assemble(chunks); end
    def split(io, file_info, offset = T.unsafe(nil)); end
  end
end

Mongo::Grid::File::Chunk::COLLECTION = T.let(T.unsafe(nil), String)
Mongo::Grid::File::Chunk::DEFAULT_SIZE = T.let(T.unsafe(nil), Integer)

class Mongo::Grid::File::Info
  def initialize(document); end

  def ==(other); end
  def bson_type; end
  def chunk_size; end
  def content_type; end
  def document; end
  def filename; end
  def id; end
  def inspect; end
  def length; end
  def md5; end
  def metadata; end
  def size; end
  def to_bson(buffer = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  def update_md5(bytes); end
  def upload_date; end

  private

  def default_document; end
end

Mongo::Grid::File::Info::COLLECTION = T.let(T.unsafe(nil), String)
Mongo::Grid::File::Info::DEFAULT_CONTENT_TYPE = T.let(T.unsafe(nil), String)
Mongo::Grid::File::Info::MAPPINGS = T.let(T.unsafe(nil), Hash)

module Mongo::Id
  class << self
    def included(klass); end
  end
end

module Mongo::Index; end
Mongo::Index::ALL = T.let(T.unsafe(nil), String)
Mongo::Index::ASCENDING = T.let(T.unsafe(nil), Integer)
Mongo::Index::COLLECTION = T.let(T.unsafe(nil), String)
Mongo::Index::DESCENDING = T.let(T.unsafe(nil), Integer)
Mongo::Index::GEO2D = T.let(T.unsafe(nil), String)
Mongo::Index::GEO2DSPHERE = T.let(T.unsafe(nil), String)
Mongo::Index::GEOHAYSTACK = T.let(T.unsafe(nil), String)
Mongo::Index::HASHED = T.let(T.unsafe(nil), String)
Mongo::Index::TEXT = T.let(T.unsafe(nil), String)

class Mongo::Index::View
  include ::Enumerable
  include ::Mongo::Retryable
  extend ::Forwardable

  def initialize(collection, options = T.unsafe(nil)); end

  def batch_size; end
  def client(*args, &block); end
  def cluster(*args, &block); end
  def collection; end
  def create_many(*models); end
  def create_one(keys, options = T.unsafe(nil)); end
  def database(*args, &block); end
  def drop_all; end
  def drop_one(name); end
  def each(&block); end
  def get(keys_or_name); end
  def next_primary(*args, &block); end
  def read_preference(*args, &block); end
  def write_concern(*args, &block); end

  private

  def drop_by_name(name); end
  def index_name(spec); end
  def indexes_spec(session); end
  def initial_query_op(session); end
  def limit; end
  def normalize_keys(spec); end
  def normalize_models(models, server); end
  def send_initial_query(server, session); end
end

Mongo::Index::View::KEY = T.let(T.unsafe(nil), String)
Mongo::Index::View::NAME = T.let(T.unsafe(nil), String)
Mongo::Index::View::OPTIONS = T.let(T.unsafe(nil), Hash)

module Mongo::Lint
  private

  def assert_type(obj, cls); end
  def enabled?; end
  def validate_camel_case_read_preference(read_pref); end
  def validate_camel_case_read_preference_mode(mode); end
  def validate_read_concern_option(read_concern); end
  def validate_underscore_read_preference(read_pref); end
  def validate_underscore_read_preference_mode(mode); end

  class << self
    def assert_type(obj, cls); end
    def enabled?; end
    def validate_camel_case_read_preference(read_pref); end
    def validate_camel_case_read_preference_mode(mode); end
    def validate_read_concern_option(read_concern); end
    def validate_underscore_read_preference(read_pref); end
    def validate_underscore_read_preference_mode(mode); end
  end
end

module Mongo::Loggable
  def log_debug(message); end
  def log_error(message); end
  def log_fatal(message); end
  def log_info(message); end
  def log_warn(message); end
  def logger; end

  private

  def _mongo_log_prefix; end
  def format_message(message); end
end

Mongo::Loggable::PREFIX = T.let(T.unsafe(nil), String)

class Mongo::Logger
  class << self
    def level; end
    def level=(level); end
    def logger; end
    def logger=(other); end

    private

    def default_logger; end
  end
end

class Mongo::Monitoring
  include ::Mongo::Id
  include ::Mongo::Monitoring::Subscribable

  def initialize(options = T.unsafe(nil)); end

  def failed(topic, event); end
  def monitoring?; end
  def options; end
  def publish_heartbeat(server, awaited: T.unsafe(nil)); end
  def published(topic, event); end
  def started(topic, event); end
  def succeeded(topic, event); end

  private

  def initialize_copy(original); end

  class << self
    def next_id; end
    def next_operation_id; end
  end
end

Mongo::Monitoring::COMMAND = T.let(T.unsafe(nil), String)
Mongo::Monitoring::CONNECTION_POOL = T.let(T.unsafe(nil), String)

class Mongo::Monitoring::CmapLogSubscriber
  include ::Mongo::Loggable

  def initialize(options = T.unsafe(nil)); end

  def options; end
  def published(event); end
end

class Mongo::Monitoring::CommandLogSubscriber
  include ::Mongo::Loggable

  def initialize(options = T.unsafe(nil)); end

  def failed(event); end
  def options; end
  def started(event); end
  def succeeded(event); end

  private

  def format_command(args); end
  def prefix(event, connection_generation: T.unsafe(nil), connection_id: T.unsafe(nil), server_connection_id: T.unsafe(nil)); end
  def truncate(command); end
  def truncating?; end
end

Mongo::Monitoring::CommandLogSubscriber::LOG_STRING_LIMIT = T.let(T.unsafe(nil), Integer)
module Mongo::Monitoring::Event; end
module Mongo::Monitoring::Event::Cmap; end
class Mongo::Monitoring::Event::Cmap::Base < ::Mongo::Event::Base; end

class Mongo::Monitoring::Event::Cmap::ConnectionCheckOutFailed < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, reason); end

  def address; end
  def reason; end
  def summary; end
end

Mongo::Monitoring::Event::Cmap::ConnectionCheckOutFailed::CONNECTION_ERROR = T.let(T.unsafe(nil), Symbol)
Mongo::Monitoring::Event::Cmap::ConnectionCheckOutFailed::POOL_CLOSED = T.let(T.unsafe(nil), Symbol)
Mongo::Monitoring::Event::Cmap::ConnectionCheckOutFailed::TIMEOUT = T.let(T.unsafe(nil), Symbol)

class Mongo::Monitoring::Event::Cmap::ConnectionCheckOutStarted < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address); end

  def address; end
  def summary; end
end

class Mongo::Monitoring::Event::Cmap::ConnectionCheckedIn < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, id, pool); end

  def address; end
  def connection_id; end
  def pool; end
  def summary; end
end

class Mongo::Monitoring::Event::Cmap::ConnectionCheckedOut < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, id, pool); end

  def address; end
  def connection_id; end
  def pool; end
  def summary; end
end

class Mongo::Monitoring::Event::Cmap::ConnectionClosed < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, id, reason); end

  def address; end
  def connection_id; end
  def reason; end
  def summary; end
end

Mongo::Monitoring::Event::Cmap::ConnectionClosed::ERROR = T.let(T.unsafe(nil), Symbol)
Mongo::Monitoring::Event::Cmap::ConnectionClosed::HANDSHAKE_FAILED = T.let(T.unsafe(nil), Symbol)
Mongo::Monitoring::Event::Cmap::ConnectionClosed::IDLE = T.let(T.unsafe(nil), Symbol)
Mongo::Monitoring::Event::Cmap::ConnectionClosed::POOL_CLOSED = T.let(T.unsafe(nil), Symbol)
Mongo::Monitoring::Event::Cmap::ConnectionClosed::STALE = T.let(T.unsafe(nil), Symbol)
Mongo::Monitoring::Event::Cmap::ConnectionClosed::UNKNOWN = T.let(T.unsafe(nil), Symbol)

class Mongo::Monitoring::Event::Cmap::ConnectionCreated < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, id); end

  def address; end
  def connection_id; end
  def summary; end
end

class Mongo::Monitoring::Event::Cmap::ConnectionReady < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, id); end

  def address; end
  def connection_id; end
  def summary; end
end

class Mongo::Monitoring::Event::Cmap::PoolCleared < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, service_id: T.unsafe(nil)); end

  def address; end
  def service_id; end
  def summary; end
end

class Mongo::Monitoring::Event::Cmap::PoolClosed < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, pool); end

  def address; end
  def pool; end
  def summary; end
end

class Mongo::Monitoring::Event::Cmap::PoolCreated < ::Mongo::Monitoring::Event::Cmap::Base
  def initialize(address, options, pool); end

  def address; end
  def options; end
  def pool; end
  def summary; end
end

class Mongo::Monitoring::Event::CommandFailed < ::Mongo::Event::Base
  include ::Mongo::Monitoring::Event::Secure

  def initialize(command_name, database_name, address, request_id, operation_id, message, failure, duration, started_event:, service_id: T.unsafe(nil)); end

  def address; end
  def command_name; end
  def database_name; end
  def duration; end
  def failure; end
  def message; end
  def operation_id; end
  def request_id; end
  def service_id; end
  def started_event; end
  def summary; end

  class << self
    def generate(address, operation_id, payload, message, failure, duration, started_event:, service_id: T.unsafe(nil)); end
  end
end

class Mongo::Monitoring::Event::CommandStarted < ::Mongo::Event::Base
  include ::Mongo::Monitoring::Event::Secure

  def initialize(command_name, database_name, address, request_id, operation_id, command, socket_object_id: T.unsafe(nil), connection_id: T.unsafe(nil), connection_generation: T.unsafe(nil), server_connection_id: T.unsafe(nil), service_id: T.unsafe(nil)); end

  def address; end
  def command; end
  def command_name; end
  def connection_generation; end
  def connection_id; end
  def database_name; end
  def inspect; end
  def operation_id; end
  def request_id; end
  def sensitive; end
  def server_connection_id; end
  def service_id; end
  def socket_object_id; end
  def summary; end

  private

  def command_summary; end

  class << self
    def generate(address, operation_id, payload, socket_object_id: T.unsafe(nil), connection_id: T.unsafe(nil), connection_generation: T.unsafe(nil), server_connection_id: T.unsafe(nil), service_id: T.unsafe(nil)); end
  end
end

class Mongo::Monitoring::Event::CommandSucceeded < ::Mongo::Event::Base
  include ::Mongo::Monitoring::Event::Secure

  def initialize(command_name, database_name, address, request_id, operation_id, reply, duration, started_event:, service_id: T.unsafe(nil)); end

  def address; end
  def command_name; end
  def database_name; end
  def duration; end
  def operation_id; end
  def reply; end
  def request_id; end
  def service_id; end
  def started_event; end
  def summary; end

  class << self
    def generate(address, operation_id, command_payload, reply_payload, duration, started_event:, service_id: T.unsafe(nil)); end
    def generate_reply(command_payload, reply_payload); end
    def namespace(payload); end
  end
end

module Mongo::Monitoring::Event::Secure
  def compression_allowed?(command_name); end
  def redacted(command_name, document); end
  def sensitive?(command_name:, document:); end
end

Mongo::Monitoring::Event::Secure::REDACTED_COMMANDS = T.let(T.unsafe(nil), Array)

class Mongo::Monitoring::Event::ServerClosed < ::Mongo::Event::Base
  def initialize(address, topology); end

  def address; end
  def summary; end
  def topology; end
end

class Mongo::Monitoring::Event::ServerDescriptionChanged < ::Mongo::Event::Base
  def initialize(address, topology, previous_description, new_description, awaited: T.unsafe(nil)); end

  def address; end
  def awaited?; end
  def new_description; end
  def previous_description; end
  def summary; end
  def topology; end

  private

  def awaited_indicator; end
end

class Mongo::Monitoring::Event::ServerHeartbeatFailed < ::Mongo::Event::Base
  def initialize(address, round_trip_time, error, started_event:, awaited: T.unsafe(nil)); end

  def address; end
  def awaited?; end
  def duration; end
  def error; end
  def failure; end
  def round_trip_time; end
  def started_event; end
  def summary; end
end

class Mongo::Monitoring::Event::ServerHeartbeatStarted < ::Mongo::Event::Base
  def initialize(address, awaited: T.unsafe(nil)); end

  def address; end
  def awaited?; end
  def summary; end
end

class Mongo::Monitoring::Event::ServerHeartbeatSucceeded < ::Mongo::Event::Base
  def initialize(address, round_trip_time, started_event:, awaited: T.unsafe(nil)); end

  def address; end
  def awaited?; end
  def duration; end
  def round_trip_time; end
  def started_event; end
  def summary; end
end

class Mongo::Monitoring::Event::ServerOpening < ::Mongo::Event::Base
  def initialize(address, topology); end

  def address; end
  def summary; end
  def topology; end
end

class Mongo::Monitoring::Event::TopologyChanged < ::Mongo::Event::Base
  def initialize(previous_topology, new_topology); end

  def new_topology; end
  def previous_topology; end
  def summary; end
end

class Mongo::Monitoring::Event::TopologyClosed < ::Mongo::Event::Base
  def initialize(topology); end

  def summary; end
  def topology; end
end

class Mongo::Monitoring::Event::TopologyOpening < ::Mongo::Event::Base
  def initialize(topology); end

  def summary; end
  def topology; end
end

module Mongo::Monitoring::Global
  extend ::Mongo::Monitoring::Subscribable
end

module Mongo::Monitoring::Publishable
  include ::Mongo::Loggable

  def monitoring; end
  def publish_cmap_event(event); end
  def publish_event(topic, event); end
  def publish_sdam_event(topic, event); end

  private

  def command_completed(result, address, operation_id, payload, duration, started_event:, service_id: T.unsafe(nil)); end
  def command_failed(failure, address, operation_id, payload, message, duration, started_event:, service_id: T.unsafe(nil)); end
  def command_started(address, operation_id, payload, socket_object_id: T.unsafe(nil), connection_id: T.unsafe(nil), connection_generation: T.unsafe(nil), server_connection_id: T.unsafe(nil), service_id: T.unsafe(nil)); end
  def command_succeeded(result, address, operation_id, payload, duration, started_event:, service_id: T.unsafe(nil)); end
  def duration(start); end
  def monitoring?; end
end

class Mongo::Monitoring::SDAMLogSubscriber
  include ::Mongo::Loggable

  def initialize(options = T.unsafe(nil)); end

  def options; end
  def succeeded(event); end
end

Mongo::Monitoring::SERVER_CLOSED = T.let(T.unsafe(nil), String)
Mongo::Monitoring::SERVER_DESCRIPTION_CHANGED = T.let(T.unsafe(nil), String)
Mongo::Monitoring::SERVER_HEARTBEAT = T.let(T.unsafe(nil), String)
Mongo::Monitoring::SERVER_OPENING = T.let(T.unsafe(nil), String)

class Mongo::Monitoring::ServerClosedLogSubscriber < ::Mongo::Monitoring::SDAMLogSubscriber
  private

  def log_event(event); end
end

class Mongo::Monitoring::ServerDescriptionChangedLogSubscriber < ::Mongo::Monitoring::SDAMLogSubscriber
  private

  def awaited_indicator(event); end
  def log_event(event); end
end

class Mongo::Monitoring::ServerOpeningLogSubscriber < ::Mongo::Monitoring::SDAMLogSubscriber
  private

  def log_event(event); end
end

module Mongo::Monitoring::Subscribable
  def subscribe(topic, subscriber); end
  def subscribers; end
  def subscribers?(topic); end
  def unsubscribe(topic, subscriber); end

  private

  def subscribers_for(topic); end
end

Mongo::Monitoring::TOPOLOGY_CHANGED = T.let(T.unsafe(nil), String)
Mongo::Monitoring::TOPOLOGY_CLOSED = T.let(T.unsafe(nil), String)
Mongo::Monitoring::TOPOLOGY_OPENING = T.let(T.unsafe(nil), String)

class Mongo::Monitoring::TopologyChangedLogSubscriber < ::Mongo::Monitoring::SDAMLogSubscriber
  private

  def log_event(event); end
end

class Mongo::Monitoring::TopologyClosedLogSubscriber < ::Mongo::Monitoring::SDAMLogSubscriber
  private

  def log_event(event); end
end

class Mongo::Monitoring::TopologyOpeningLogSubscriber < ::Mongo::Monitoring::SDAMLogSubscriber
  private

  def log_event(event); end
end

class Mongo::Monitoring::UnifiedSdamLogSubscriber
  include ::Mongo::Loggable

  def initialize(options = T.unsafe(nil)); end

  def options; end
  def published(event); end
  def subscribe(client); end
  def succeeded(event); end
end

module Mongo::Operation; end
Mongo::Operation::ARRAY_FILTERS = T.let(T.unsafe(nil), String)

class Mongo::Operation::Aggregate
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::Aggregate::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  include ::Mongo::Operation::ReadPreferenceSupported
  include ::Mongo::Operation::WriteConcernSupported
  include ::Mongo::Operation::Limited
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
  def selector(connection); end
  def write_concern_supported?(connection); end
end

class Mongo::Operation::Aggregate::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::CausalConsistencySupported
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods
end

class Mongo::Operation::Aggregate::Result < ::Mongo::Operation::Result
  def cursor_id; end
  def documents; end
  def post_batch_resume_token; end

  private

  def cursor_document; end
  def explain_document; end
  def first_document; end
end

Mongo::Operation::Aggregate::Result::EXPLAIN = T.let(T.unsafe(nil), String)
Mongo::Operation::Aggregate::Result::EXPLAIN_LEGACY = T.let(T.unsafe(nil), String)

module Mongo::Operation::BypassDocumentValidation
  private

  def add_bypass_document_validation(sel); end
  def command(connection); end
end

Mongo::Operation::CLUSTER_TIME = T.let(T.unsafe(nil), String)
Mongo::Operation::COLLATION = T.let(T.unsafe(nil), String)

module Mongo::Operation::CausalConsistencySupported
  private

  def apply_causal_consistency!(selector, connection); end
end

class Mongo::Operation::CollectionsInfo
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup

  private

  def final_operation(connection); end
end

class Mongo::Operation::CollectionsInfo::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::ReadPreferenceSupported
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def get_result(connection, context, options = T.unsafe(nil)); end
  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::CollectionsInfo::Result < ::Mongo::Operation::Result
  def initialize(replies, connection_description, database_name); end

  def namespace; end
end

class Mongo::Operation::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::Command::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ReadPreferenceSupported

  private

  def message(connection); end
end

class Mongo::Operation::Command::OpMsg < ::Mongo::Operation::OpMsgBase; end

class Mongo::Operation::Context
  def initialize(client: T.unsafe(nil), session: T.unsafe(nil), service_id: T.unsafe(nil), options: T.unsafe(nil)); end

  def aborting_transaction?; end
  def any_retry_writes?; end
  def client; end
  def committing_transaction?; end
  def decrypt?; end
  def encrypt?; end
  def encrypter; end
  def in_transaction?; end
  def legacy_retry_writes?; end
  def modern_retry_writes?; end
  def options; end
  def server_api; end
  def service_id; end
  def session; end
  def starting_transaction?; end
end

class Mongo::Operation::Count
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::Count::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ReadPreferenceSupported

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::Count::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::CausalConsistencySupported

  private

  def selector(connection); end
end

class Mongo::Operation::Create
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::Create::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::WriteConcernSupported

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::Create::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(connection); end
end

class Mongo::Operation::CreateIndex
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::CreateIndex::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::WriteConcernSupported

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::CreateIndex::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(connection); end
end

class Mongo::Operation::CreateUser
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::CreateUser::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ReadPreferenceSupported
  include ::Mongo::Operation::WriteConcernSupported

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::CreateUser::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(connection); end
end

class Mongo::Operation::Delete
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Write
end

class Mongo::Operation::Delete::BulkResult < ::Mongo::Operation::Result
  include ::Mongo::Operation::Result::Aggregatable

  def n_removed; end
end

class Mongo::Operation::Delete::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::WriteConcernSupported
  include ::Mongo::Operation::ExecutableNoValidate
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  include ::Mongo::Operation::Validatable
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
  def selector(connection); end
end

Mongo::Operation::Delete::IDENTIFIER = T.let(T.unsafe(nil), String)

class Mongo::Operation::Delete::Legacy
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  include ::Mongo::Operation::Validatable
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def gle; end
  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::Delete::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::BypassDocumentValidation
  include ::Mongo::Operation::ExecutableNoValidate
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  include ::Mongo::Operation::Validatable
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::Delete::Result < ::Mongo::Operation::Result
  def bulk_result; end
  def deleted_count; end
end

class Mongo::Operation::Distinct
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::Distinct::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ReadPreferenceSupported

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::Distinct::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::CausalConsistencySupported
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(connection); end
end

class Mongo::Operation::Drop
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::Drop::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::WriteConcernSupported

  private

  def message(connection); end
end

class Mongo::Operation::Drop::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel
end

class Mongo::Operation::DropDatabase
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::DropDatabase::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::WriteConcernSupported

  private

  def message(connection); end
end

class Mongo::Operation::DropDatabase::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel
end

class Mongo::Operation::DropIndex
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::DropIndex::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::WriteConcernSupported

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::DropIndex::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(connection); end
end

module Mongo::Operation::Executable
  include ::Mongo::Operation::ResponseHandling

  def do_execute(connection, context, options = T.unsafe(nil)); end
  def execute(connection, context:, options: T.unsafe(nil)); end

  private

  def build_message(connection, context); end
  def dispatch_message(connection, context, options = T.unsafe(nil)); end
  def get_result(connection, context, options = T.unsafe(nil)); end
  def process_result(result, connection); end
  def process_result_for_sdam(result, connection); end
  def result_class; end
end

module Mongo::Operation::ExecutableNoValidate
  def execute(connection, context:); end
end

module Mongo::Operation::ExecutableTransactionLabel; end

class Mongo::Operation::Explain
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrFindCommand
end

class Mongo::Operation::Explain::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ReadPreferenceSupported
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::Explain::Legacy
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::ReadPreferenceSupported
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
end

class Mongo::Operation::Explain::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::CausalConsistencySupported
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def selector(connection); end
end

class Mongo::Operation::Explain::Result < ::Mongo::Operation::Result
  def cursor_id; end
  def documents; end
end

class Mongo::Operation::Find
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrFindCommand
end

module Mongo::Operation::Find::Builder; end

module Mongo::Operation::Find::Builder::Command
  private

  def convert_limit_and_batch_size!(command); end
  def selector(spec, connection); end

  class << self
    def convert_limit_and_batch_size!(command); end
    def selector(spec, connection); end
  end
end

Mongo::Operation::Find::Builder::Command::OPTION_MAPPINGS = T.let(T.unsafe(nil), BSON::Document)

module Mongo::Operation::Find::Builder::Flags
  private

  def map_flags(options); end

  class << self
    def map_flags(options); end
  end
end

Mongo::Operation::Find::Builder::Flags::MAPPINGS = T.let(T.unsafe(nil), Hash)

module Mongo::Operation::Find::Builder::Legacy
  private

  def query_options(spec, connection); end
  def read_pref_formatted(spec); end
  def selector(spec, connection); end

  class << self
    def query_options(spec, connection); end
    def read_pref_formatted(spec); end
    def selector(spec, connection); end
  end
end

Mongo::Operation::Find::Builder::Legacy::DRIVER_MAPPINGS = T.let(T.unsafe(nil), Hash)

module Mongo::Operation::Find::Builder::Modifiers
  private

  def map_driver_options(modifiers); end
  def map_server_modifiers(options); end

  class << self
    def map_driver_options(modifiers); end
    def map_server_modifiers(options); end
  end
end

Mongo::Operation::Find::Builder::Modifiers::DRIVER_MAPPINGS = T.let(T.unsafe(nil), BSON::Document)
Mongo::Operation::Find::Builder::Modifiers::SERVER_MAPPINGS = T.let(T.unsafe(nil), BSON::Document)

class Mongo::Operation::Find::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ReadPreferenceSupported
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::Find::Legacy
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::ReadPreferenceSupported
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
end

class Mongo::Operation::Find::Legacy::Result < ::Mongo::Operation::Result
  include ::Mongo::Operation::Result::UseLegacyErrorParser

  def successful?; end
end

class Mongo::Operation::Find::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::CausalConsistencySupported
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def selector(connection); end
end

class Mongo::Operation::Find::Result < ::Mongo::Operation::Result
  def cursor_id; end
  def documents; end
  def namespace; end

  private

  def cursor_document; end
  def first_document; end
end

class Mongo::Operation::GetMore
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrFindCommand
end

class Mongo::Operation::GetMore::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ReadPreferenceSupported
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  include ::Mongo::Operation::GetMore::CommandBuilder
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
end

module Mongo::Operation::GetMore::CommandBuilder
  private

  def selector(connection); end
end

class Mongo::Operation::GetMore::Legacy
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable

  private

  def message(connection); end
end

class Mongo::Operation::GetMore::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  include ::Mongo::Operation::GetMore::CommandBuilder
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods
end

class Mongo::Operation::GetMore::Result < ::Mongo::Operation::Result
  def cursor_id; end
  def documents; end
  def post_batch_resume_token; end

  private

  def cursor_document; end
  def first_document; end
end

module Mongo::Operation::Idable
  def documents; end

  private

  def ensure_ids(documents); end
  def has_id?(doc); end
  def id(doc); end
  def id_generator; end
end

Mongo::Operation::Idable::ID_GENERATOR = T.let(T.unsafe(nil), Symbol)

class Mongo::Operation::Indexes
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup

  private

  def final_operation(connection); end
end

class Mongo::Operation::Indexes::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ReadPreferenceSupported
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
end

class Mongo::Operation::Indexes::Legacy
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::ReadPreferenceSupported

  private

  def message(connection); end
  def result_class; end
  def selector(connection); end
end

class Mongo::Operation::Indexes::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods
end

class Mongo::Operation::Indexes::Result < ::Mongo::Operation::Result
  def cursor_id; end
  def documents; end
  def namespace; end
  def validate!; end

  private

  def cursor_document; end
  def first_document; end
end

class Mongo::Operation::Insert
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Write

  private

  def validate!(connection); end
end

class Mongo::Operation::Insert::BulkResult < ::Mongo::Operation::Result
  include ::Mongo::Operation::Result::Aggregatable

  def initialize(replies, connection_description, ids); end

  def inserted_id; end
  def inserted_ids; end
  def n_inserted; end
end

class Mongo::Operation::Insert::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::ExecutableNoValidate
  include ::Mongo::Operation::Idable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::WriteConcernSupported
  include ::Mongo::Operation::BypassDocumentValidation

  private

  def get_result(connection, context, options = T.unsafe(nil)); end
  def message(connection); end
  def options(server); end
  def selector(connection); end
end

Mongo::Operation::Insert::IDENTIFIER = T.let(T.unsafe(nil), String)

class Mongo::Operation::Insert::Legacy
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Idable

  private

  def get_result(connection, context, options = T.unsafe(nil)); end
  def gle; end
  def message(connection); end
  def selector; end
end

class Mongo::Operation::Insert::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::Idable
  include ::Mongo::Operation::BypassDocumentValidation
  include ::Mongo::Operation::ExecutableNoValidate
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def get_result(connection, context, options = T.unsafe(nil)); end
  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::Insert::Result < ::Mongo::Operation::Result
  def initialize(replies, connection_description, ids); end

  def bulk_result; end
  def inserted_id; end
  def inserted_ids; end
end

class Mongo::Operation::KillCursors
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrFindCommand
end

class Mongo::Operation::KillCursors::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::KillCursors::CommandBuilder

  private

  def message(connection); end
  def selector(connection); end
end

module Mongo::Operation::KillCursors::CommandBuilder
  private

  def int64_cursor_ids; end
end

class Mongo::Operation::KillCursors::Legacy
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::KillCursors::CommandBuilder

  private

  def message(connection); end
end

class Mongo::Operation::KillCursors::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::KillCursors::CommandBuilder

  private

  def selector(connection); end
end

Mongo::Operation::LIMIT = T.let(T.unsafe(nil), String)

module Mongo::Operation::Limited
  private

  def options(connection); end
end

class Mongo::Operation::ListCollections
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::ListCollections::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ReadPreferenceSupported
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::ListCollections::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def selector(connection); end
end

class Mongo::Operation::ListCollections::Result < ::Mongo::Operation::Result
  def cursor_id; end
  def documents; end
  def namespace; end
  def validate!; end

  private

  def cursor_document; end
  def first_document; end
end

Mongo::Operation::MULTI = T.let(T.unsafe(nil), String)

class Mongo::Operation::MapReduce
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::MapReduce::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ReadPreferenceSupported
  include ::Mongo::Operation::WriteConcernSupported
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::MapReduce::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::CausalConsistencySupported
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods
end

class Mongo::Operation::MapReduce::Result < ::Mongo::Operation::Result
  def counts; end
  def cursor_id; end
  def documents; end
  def successful?; end
  def time; end
  def validate!; end

  private

  def first_document; end
end

Mongo::Operation::MapReduce::Result::COUNTS = T.let(T.unsafe(nil), String)
Mongo::Operation::MapReduce::Result::RESULTS = T.let(T.unsafe(nil), String)
Mongo::Operation::MapReduce::Result::TIME = T.let(T.unsafe(nil), String)
Mongo::Operation::OPERATION_TIME = T.let(T.unsafe(nil), String)

class Mongo::Operation::ObjectIdGenerator
  def generate; end
end

class Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::SessionsSupported

  private

  def message(connection); end
end

module Mongo::Operation::OpMsgOrCommand
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup

  private

  def final_operation(connection); end
end

module Mongo::Operation::OpMsgOrFindCommand
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup

  private

  def final_operation(connection); end
end

class Mongo::Operation::ParallelScan
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::ParallelScan::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ReadPreferenceSupported
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::ParallelScan::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::CausalConsistencySupported
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def selector(connection); end
end

class Mongo::Operation::ParallelScan::Result < ::Mongo::Operation::Result
  def cursor_ids; end
  def documents; end

  private

  def first; end
end

Mongo::Operation::ParallelScan::Result::CURSORS = T.let(T.unsafe(nil), String)

module Mongo::Operation::PolymorphicLookup
  private

  def polymorphic_class(base, name); end
end

module Mongo::Operation::PolymorphicOperation
  def execute(server, context:, options: T.unsafe(nil)); end
end

module Mongo::Operation::PolymorphicResult
  include ::Mongo::Operation::PolymorphicLookup

  mixes_in_class_methods ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def result_class; end

  class << self
    def included(base); end
  end
end

module Mongo::Operation::PolymorphicResult::ClassMethods
  def result_class; end
  def result_class=(_arg0); end
end

Mongo::Operation::Q = T.let(T.unsafe(nil), String)

module Mongo::Operation::ReadPreferenceSupported
  private

  def add_read_preference_legacy(sel, connection); end
  def add_secondary_ok_flag?(connection); end
  def command(connection); end
  def options(connection); end
end

class Mongo::Operation::RemoveUser
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::RemoveUser::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ReadPreferenceSupported
  include ::Mongo::Operation::WriteConcernSupported

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::RemoveUser::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(connection); end
end

module Mongo::Operation::ResponseHandling
  private

  def add_error_labels(connection, context); end
  def add_server_diagnostics(connection); end
  def maybe_add_retryable_write_error_label!(error, connection, context); end
  def unpin_maybe(session); end
  def validate_result(result, connection, context); end
end

class Mongo::Operation::Result
  include ::Enumerable
  extend ::Forwardable

  def initialize(replies, connection_description = T.unsafe(nil)); end

  def acknowledged?; end
  def cluster_time; end
  def connection_description; end
  def cursor_id; end
  def documents; end
  def each(&block); end
  def error; end
  def inspect; end
  def labels; end
  def n; end
  def namespace; end
  def node_recovering?(*args, &block); end
  def node_shutting_down?(*args, &block); end
  def not_master?(*args, &block); end
  def ok?; end
  def operation_time; end
  def replies; end
  def reply; end
  def returned_count; end
  def snapshot_timestamp; end
  def successful?; end
  def topology_version; end
  def validate!; end
  def write_concern_error?; end
  def written_count; end

  private

  def aggregate_returned_count; end
  def aggregate_written_count; end
  def first_document; end
  def parser; end
  def query_failure?; end
  def raise_operation_failure; end
end

module Mongo::Operation::Result::Aggregatable
  def aggregate_write_concern_errors(count); end
  def aggregate_write_errors(count); end
end

Mongo::Operation::Result::CURSOR = T.let(T.unsafe(nil), String)
Mongo::Operation::Result::CURSOR_ID = T.let(T.unsafe(nil), String)
Mongo::Operation::Result::FIRST_BATCH = T.let(T.unsafe(nil), String)
Mongo::Operation::Result::N = T.let(T.unsafe(nil), String)
Mongo::Operation::Result::NAMESPACE = T.let(T.unsafe(nil), String)
Mongo::Operation::Result::NEXT_BATCH = T.let(T.unsafe(nil), String)
Mongo::Operation::Result::OK = T.let(T.unsafe(nil), String)
Mongo::Operation::Result::RESULT = T.let(T.unsafe(nil), String)

module Mongo::Operation::Result::UseLegacyErrorParser
  def parser; end
end

module Mongo::Operation::SessionsSupported
  private

  def add_read_preference(sel, connection); end
  def add_write_concern!(sel); end
  def apply_autocommit!(selector); end
  def apply_causal_consistency!(selector, connection); end
  def apply_causal_consistency_if_possible(selector, connection); end
  def apply_cluster_time!(selector, connection); end
  def apply_read_pref!(selector); end
  def apply_session_options(sel, connection); end
  def apply_start_transaction!(selector); end
  def apply_txn_num!(selector); end
  def apply_txn_opts!(selector); end
  def build_message(connection, context); end
  def command(connection); end
  def flags; end
  def read_command?(sel); end
  def suppress_read_write_concern!(selector); end
  def validate_read_preference!(selector); end
end

Mongo::Operation::SessionsSupported::READ_COMMANDS = T.let(T.unsafe(nil), Array)
Mongo::Operation::SessionsSupported::ZERO_TIMESTAMP = T.let(T.unsafe(nil), BSON::Timestamp)

module Mongo::Operation::Specifiable
  def initialize(spec); end

  def ==(other); end
  def acknowledged_write?; end
  def apply_collation(selector, connection, collation); end
  def array_filters(connection); end
  def bypass_document_validation; end
  def coll_name; end
  def collation; end
  def command(connection); end
  def cursor_count; end
  def cursor_id; end
  def db_name; end
  def delete; end
  def deletes; end
  def documents; end
  def eql?(other); end
  def index; end
  def index_name; end
  def indexes; end
  def max_time_ms; end
  def namespace; end
  def operation_id; end
  def options(connection); end
  def ordered?; end
  def read; end
  def read_concern; end
  def selector(connection); end
  def session; end
  def spec; end
  def to_return; end
  def txn_num; end
  def update; end
  def updates; end
  def user; end
  def user_name; end
  def write_concern; end
end

Mongo::Operation::Specifiable::BYPASS_DOC_VALIDATION = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::COLLATION = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::COLL_NAME = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::CURSOR_COUNT = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::CURSOR_ID = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::DB_NAME = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::DELETE = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::DELETES = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::DOCUMENTS = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::INDEX = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::INDEXES = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::INDEX_NAME = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::MAX_TIME_MS = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::OPERATION_ID = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::OPTIONS = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::READ = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::READ_CONCERN = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::SELECTOR = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::TO_RETURN = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::UPDATE = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::UPDATES = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::USER = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::USER_NAME = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::Specifiable::WRITE_CONCERN = T.let(T.unsafe(nil), Symbol)
Mongo::Operation::U = T.let(T.unsafe(nil), String)
Mongo::Operation::UPSERT = T.let(T.unsafe(nil), String)

class Mongo::Operation::Update
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Write
end

class Mongo::Operation::Update::BulkResult < ::Mongo::Operation::Result
  include ::Mongo::Operation::Result::Aggregatable

  def n_matched; end
  def n_modified; end
  def n_upserted; end
  def upserted; end

  private

  def upsert?(reply); end
end

Mongo::Operation::Update::BulkResult::MODIFIED = T.let(T.unsafe(nil), String)
Mongo::Operation::Update::BulkResult::UPSERTED = T.let(T.unsafe(nil), String)

class Mongo::Operation::Update::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::WriteConcernSupported
  include ::Mongo::Operation::BypassDocumentValidation
  include ::Mongo::Operation::ExecutableNoValidate
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  include ::Mongo::Operation::Validatable
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
  def selector(connection); end
end

Mongo::Operation::Update::IDENTIFIER = T.let(T.unsafe(nil), String)

class Mongo::Operation::Update::Legacy
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  include ::Mongo::Operation::Validatable
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def gle; end
  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::Update::Legacy::Result < ::Mongo::Operation::Result
  include ::Mongo::Operation::Result::UseLegacyErrorParser

  def matched_count; end
  def modified_count; end
  def upserted_count; end
  def upserted_id; end

  private

  def updated_existing?; end
  def upsert?; end
end

Mongo::Operation::Update::Legacy::Result::UPDATED_EXISTING = T.let(T.unsafe(nil), String)
Mongo::Operation::Update::Legacy::Result::UPSERTED = T.let(T.unsafe(nil), String)

class Mongo::Operation::Update::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::BypassDocumentValidation
  include ::Mongo::Operation::ExecutableNoValidate
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  include ::Mongo::Operation::Validatable
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::Update::Result < ::Mongo::Operation::Result
  def bulk_result; end
  def matched_count; end
  def modified_count; end
  def upserted_count; end
  def upserted_id; end

  private

  def upsert?; end
end

Mongo::Operation::Update::Result::MODIFIED = T.let(T.unsafe(nil), String)
Mongo::Operation::Update::Result::UPSERTED = T.let(T.unsafe(nil), String)

class Mongo::Operation::UpdateUser
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::UpdateUser::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::WriteConcernSupported

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::UpdateUser::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel

  private

  def selector(connection); end
end

class Mongo::Operation::UsersInfo
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::UsersInfo::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ReadPreferenceSupported
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::UsersInfo::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::ExecutableTransactionLabel
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::PolymorphicResult
  extend ::Mongo::Operation::PolymorphicResult::ClassMethods

  private

  def selector(connection); end
end

class Mongo::Operation::UsersInfo::Result < ::Mongo::Operation::Result
  def documents; end

  private

  def first_document; end
end

Mongo::Operation::UsersInfo::Result::USERS = T.let(T.unsafe(nil), String)

module Mongo::Operation::Validatable
  def validate_array_filters(connection, selector_or_item); end
  def validate_collation(connection, selector_or_item); end
  def validate_find_options(connection, selector); end
  def validate_hint_on_update(connection, selector_or_item); end
  def validate_updates(connection, updates); end
end

module Mongo::Operation::Write
  include ::Mongo::Operation::ResponseHandling

  def bulk_execute(connection, context:); end
  def execute(server, context:); end

  private

  def validate!(connection); end
end

class Mongo::Operation::WriteCommand
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::PolymorphicOperation
  include ::Mongo::Operation::PolymorphicLookup
  include ::Mongo::Operation::OpMsgOrCommand
end

class Mongo::Operation::WriteCommand::Command
  include ::Mongo::Operation::Specifiable
  include ::Mongo::Operation::ResponseHandling
  include ::Mongo::Operation::Executable
  include ::Mongo::Operation::Limited
  include ::Mongo::Operation::ReadPreferenceSupported
  include ::Mongo::Operation::Validatable

  private

  def message(connection); end
  def selector(connection); end
end

class Mongo::Operation::WriteCommand::OpMsg < ::Mongo::Operation::OpMsgBase
  include ::Mongo::Operation::Validatable

  private

  def selector(connection); end
end

module Mongo::Operation::WriteConcernSupported
  private

  def add_write_concern!(sel, connection); end
  def command(connection); end
  def write_concern_supported?(connection); end
end

module Mongo::Options; end

module Mongo::Options::Mapper
  extend ::Mongo::Options::Mapper

  def transform(options, mappings); end
  def transform_documents(options, mappings, document = T.unsafe(nil)); end
  def transform_keys_to_strings(options); end
  def transform_keys_to_symbols(options); end
  def transform_values_to_strings(options); end
end

class Mongo::Options::Redacted < ::BSON::Document
  def has_key?(key); end
  def inspect; end
  def key?(key); end
  def reject(&block); end
  def reject!; end
  def select(&block); end
  def select!; end
  def to_s; end

  private

  def redact(k, v, method); end
  def redacted_string(method); end
end

Mongo::Options::Redacted::SENSITIVE_OPTIONS = T.let(T.unsafe(nil), Array)
Mongo::Options::Redacted::STRING_REPLACEMENT = T.let(T.unsafe(nil), String)
module Mongo::Protocol; end

class Mongo::Protocol::Compressed < ::Mongo::Protocol::Message
  def initialize(message, compressor, zlib_compression_level = T.unsafe(nil)); end

  def compressed_message; end
  def compressor_id; end
  def maybe_inflate; end
  def op_code; end
  def original_op_code; end
  def replyable?; end
  def uncompressed_size; end

  private

  def compress(buffer); end
  def decompress(compressed_message); end
  def serialize_fields(buffer, max_bson_size); end
end

Mongo::Protocol::Compressed::COMPRESSOR_ID_MAP = T.let(T.unsafe(nil), Hash)
Mongo::Protocol::Compressed::NOOP = T.let(T.unsafe(nil), String)
Mongo::Protocol::Compressed::NOOP_BYTE = T.let(T.unsafe(nil), String)
Mongo::Protocol::Compressed::OP_CODE = T.let(T.unsafe(nil), Integer)
Mongo::Protocol::Compressed::SNAPPY = T.let(T.unsafe(nil), String)
Mongo::Protocol::Compressed::SNAPPY_BYTE = T.let(T.unsafe(nil), String)
Mongo::Protocol::Compressed::ZLIB = T.let(T.unsafe(nil), String)
Mongo::Protocol::Compressed::ZLIB_BYTE = T.let(T.unsafe(nil), String)
Mongo::Protocol::Compressed::ZSTD = T.let(T.unsafe(nil), String)
Mongo::Protocol::Compressed::ZSTD_BYTE = T.let(T.unsafe(nil), String)

class Mongo::Protocol::Delete < ::Mongo::Protocol::Message
  def initialize(database, collection, selector, options = T.unsafe(nil)); end

  def flags; end
  def namespace; end
  def op_code; end
  def payload; end
  def selector; end
  def zero; end

  protected

  def upconverter; end
end

Mongo::Protocol::Delete::FLAGS = T.let(T.unsafe(nil), Array)
Mongo::Protocol::Delete::OP_CODE = T.let(T.unsafe(nil), Integer)

class Mongo::Protocol::Delete::Upconverter
  def initialize(collection, filter, options); end

  def collection; end
  def command; end
  def filter; end
  def options; end

  private

  def limit; end
end

Mongo::Protocol::Delete::Upconverter::DELETE = T.let(T.unsafe(nil), String)
Mongo::Protocol::Delete::Upconverter::DELETES = T.let(T.unsafe(nil), String)

class Mongo::Protocol::GetMore < ::Mongo::Protocol::Message
  def initialize(database, collection, number_to_return, cursor_id); end

  def cursor_id; end
  def namespace; end
  def number_to_return; end
  def op_code; end
  def payload; end
  def replyable?; end
  def zero; end

  protected

  def upconverter; end
end

Mongo::Protocol::GetMore::OP_CODE = T.let(T.unsafe(nil), Integer)

class Mongo::Protocol::GetMore::Upconverter
  def initialize(collection, cursor_id, number_to_return); end

  def collection; end
  def command; end
  def cursor_id; end
  def number_to_return; end
end

Mongo::Protocol::GetMore::Upconverter::GET_MORE = T.let(T.unsafe(nil), String)

class Mongo::Protocol::Insert < ::Mongo::Protocol::Message
  def initialize(database, collection, documents, options = T.unsafe(nil)); end

  def documents; end
  def flags; end
  def namespace; end
  def op_code; end
  def payload; end

  protected

  def upconverter; end

  private

  def validating_keys?; end
end

Mongo::Protocol::Insert::FLAGS = T.let(T.unsafe(nil), Array)
Mongo::Protocol::Insert::OP_CODE = T.let(T.unsafe(nil), Integer)

class Mongo::Protocol::Insert::Upconverter
  def initialize(collection, documents, options); end

  def collection; end
  def command; end
  def documents; end
  def options; end
end

Mongo::Protocol::Insert::Upconverter::DOCUMENTS = T.let(T.unsafe(nil), String)
Mongo::Protocol::Insert::Upconverter::INSERT = T.let(T.unsafe(nil), String)
Mongo::Protocol::Insert::Upconverter::WRITE_CONCERN = T.let(T.unsafe(nil), String)

class Mongo::Protocol::KillCursors < ::Mongo::Protocol::Message
  def initialize(collection, database, cursor_ids); end

  def cursor_ids; end
  def id_count; end
  def op_code; end
  def payload; end
  def zero; end

  protected

  def upconverter; end
end

Mongo::Protocol::KillCursors::OP_CODE = T.let(T.unsafe(nil), Integer)

class Mongo::Protocol::KillCursors::Upconverter
  def initialize(collection, cursor_ids); end

  def collection; end
  def command; end
  def cursor_ids; end
end

class Mongo::Protocol::Message
  include ::Mongo::Id
  include ::Mongo::Protocol::Serializers

  def initialize(*args); end

  def ==(other); end
  def eql?(other); end
  def hash; end
  def maybe_add_server_api(server_api); end
  def maybe_compress(compressor, zlib_compression_level = T.unsafe(nil)); end
  def maybe_decrypt(context); end
  def maybe_encrypt(connection, context); end
  def maybe_inflate; end
  def number_returned; end
  def replyable?; end
  def request_id; end
  def serialize(buffer = T.unsafe(nil), max_bson_size = T.unsafe(nil), bson_overhead = T.unsafe(nil)); end
  def set_request_id; end
  def to_s(buffer = T.unsafe(nil), max_bson_size = T.unsafe(nil), bson_overhead = T.unsafe(nil)); end

  private

  def compress_if_possible(command_name, compressor, zlib_compression_level); end
  def fields; end
  def merge_sections; end
  def serialize_fields(buffer, max_bson_size = T.unsafe(nil)); end
  def serialize_header(buffer); end
  def validating_keys?; end

  class << self
    def deserialize(io, max_message_size = T.unsafe(nil), expected_response_to = T.unsafe(nil), options = T.unsafe(nil)); end
    def deserialize_array(message, io, field, options = T.unsafe(nil)); end
    def deserialize_field(message, io, field, options = T.unsafe(nil)); end
    def deserialize_header(io); end
    def field(name, type, multi = T.unsafe(nil)); end
    def fields; end
    def next_id; end
  end
end

Mongo::Protocol::Message::BATCH_SIZE = T.let(T.unsafe(nil), String)
Mongo::Protocol::Message::COLLECTION = T.let(T.unsafe(nil), String)
Mongo::Protocol::Message::LIMIT = T.let(T.unsafe(nil), String)
Mongo::Protocol::Message::MAX_MESSAGE_SIZE = T.let(T.unsafe(nil), Integer)
Mongo::Protocol::Message::ORDERED = T.let(T.unsafe(nil), String)
Mongo::Protocol::Message::Q = T.let(T.unsafe(nil), String)

class Mongo::Protocol::Msg < ::Mongo::Protocol::Message
  include ::Mongo::Monitoring::Event::Secure

  def initialize(flags, options, main_document, *sequences); end

  def bulk_write?; end
  def documents; end
  def fix_after_deserialization; end
  def flags; end
  def maybe_add_server_api(server_api); end
  def maybe_compress(compressor, zlib_compression_level = T.unsafe(nil)); end
  def maybe_decrypt(context); end
  def maybe_encrypt(connection, context); end
  def op_code; end
  def payload; end
  def replyable?; end
  def sections; end
  def serialize(buffer = T.unsafe(nil), max_bson_size = T.unsafe(nil), bson_overhead = T.unsafe(nil)); end

  private

  def add_check_sum(buffer); end
  def command; end
  def validate_document_size!(max_bson_size); end
end

Mongo::Protocol::Msg::DATABASE_IDENTIFIER = T.let(T.unsafe(nil), String)
Mongo::Protocol::Msg::FLAGS = T.let(T.unsafe(nil), Array)
Mongo::Protocol::Msg::INTERNAL_KEYS = T.let(T.unsafe(nil), Set)
Mongo::Protocol::Msg::KNOWN_FLAGS = T.let(T.unsafe(nil), Hash)
Mongo::Protocol::Msg::OP_CODE = T.let(T.unsafe(nil), Integer)

class Mongo::Protocol::Msg::Section1
  def initialize(identifier, documents); end

  def ==(other); end
  def documents; end
  def eql?(other); end
  def identifier; end
end

class Mongo::Protocol::Query < ::Mongo::Protocol::Message
  include ::Mongo::Monitoring::Event::Secure

  def initialize(database, collection, selector, options = T.unsafe(nil)); end

  def flags; end
  def limit; end
  def maybe_compress(compressor, zlib_compression_level = T.unsafe(nil)); end
  def namespace; end
  def op_code; end
  def payload; end
  def project; end
  def replyable?; end
  def selector; end
  def serialize(buffer = T.unsafe(nil), max_bson_size = T.unsafe(nil), bson_overhead = T.unsafe(nil)); end
  def skip; end

  protected

  def upconverter; end

  private

  def determine_limit; end
  def validate_document_size!(max_bson_size); end
end

Mongo::Protocol::Query::FLAGS = T.let(T.unsafe(nil), Array)
Mongo::Protocol::Query::OP_CODE = T.let(T.unsafe(nil), Integer)

class Mongo::Protocol::Query::Upconverter
  def initialize(collection, filter, options, flags); end

  def collection; end
  def command; end
  def command_name; end
  def filter; end
  def flags; end
  def options; end

  private

  def command?; end
  def find_command; end
  def op_command; end
  def query_filter; end
end

Mongo::Protocol::Query::Upconverter::FLAG_MAPPINGS = T.let(T.unsafe(nil), Hash)
Mongo::Protocol::Query::Upconverter::OPTION_MAPPINGS = T.let(T.unsafe(nil), Hash)
Mongo::Protocol::Query::Upconverter::SPECIAL_FIELD_MAPPINGS = T.let(T.unsafe(nil), Hash)

module Mongo::Protocol::Registry
  extend ::Mongo::Protocol::Registry

  def get(op_code, message = T.unsafe(nil)); end
  def register(op_code, type); end

  private

  def define_type_reader(type); end
  def handle_unsupported_op_code!(op_code); end
end

Mongo::Protocol::Registry::MAPPINGS = T.let(T.unsafe(nil), Hash)

class Mongo::Protocol::Reply < ::Mongo::Protocol::Message
  def cursor_id; end
  def cursor_not_found?; end
  def documents; end
  def flags; end
  def number_returned; end
  def op_code; end
  def payload; end
  def query_failure?; end
  def starting_from; end

  private

  def upconverter; end
end

Mongo::Protocol::Reply::FLAGS = T.let(T.unsafe(nil), Array)
Mongo::Protocol::Reply::OP_CODE = T.let(T.unsafe(nil), Integer)

class Mongo::Protocol::Reply::Upconverter
  def initialize(documents, cursor_id, starting_from); end

  def command; end
  def cursor_id; end
  def documents; end
  def starting_from; end

  private

  def batch_field; end
  def command?; end
  def find_command; end
  def op_command; end
end

Mongo::Protocol::Reply::Upconverter::CURSOR = T.let(T.unsafe(nil), String)
Mongo::Protocol::Reply::Upconverter::FIRST_BATCH = T.let(T.unsafe(nil), String)
Mongo::Protocol::Reply::Upconverter::ID = T.let(T.unsafe(nil), String)
Mongo::Protocol::Reply::Upconverter::NEXT_BATCH = T.let(T.unsafe(nil), String)
module Mongo::Protocol::Serializers; end

class Mongo::Protocol::Serializers::BitVector
  def initialize(layout); end

  def deserialize(buffer, options = T.unsafe(nil)); end
  def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
end

module Mongo::Protocol::Serializers::Byte
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
  end
end

module Mongo::Protocol::Serializers::Bytes
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
  end
end

module Mongo::Protocol::Serializers::CString
  class << self
    def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
  end
end

module Mongo::Protocol::Serializers::Document
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, max_bson_size = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
    def size_limited?; end
  end
end

Mongo::Protocol::Serializers::HEADER_PACK = T.let(T.unsafe(nil), String)

module Mongo::Protocol::Serializers::Header
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
  end
end

Mongo::Protocol::Serializers::INT32_PACK = T.let(T.unsafe(nil), String)
Mongo::Protocol::Serializers::INT64_PACK = T.let(T.unsafe(nil), String)

module Mongo::Protocol::Serializers::Int32
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
  end
end

module Mongo::Protocol::Serializers::Int64
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
  end
end

Mongo::Protocol::Serializers::NULL = T.let(T.unsafe(nil), String)

module Mongo::Protocol::Serializers::Sections
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, max_bson_size = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
    def size_limited?; end
  end
end

module Mongo::Protocol::Serializers::Sections::PayloadOne
  class << self
    def deserialize(buffer); end
    def serialize(buffer, value, max_bson_size = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  end
end

Mongo::Protocol::Serializers::Sections::PayloadOne::TYPE = T.let(T.unsafe(nil), Integer)
Mongo::Protocol::Serializers::Sections::PayloadOne::TYPE_BYTE = T.let(T.unsafe(nil), String)

module Mongo::Protocol::Serializers::Sections::PayloadZero
  class << self
    def deserialize(buffer, options = T.unsafe(nil)); end
    def serialize(buffer, value, max_bson_size = T.unsafe(nil), validating_keys = T.unsafe(nil)); end
  end
end

Mongo::Protocol::Serializers::Sections::PayloadZero::TYPE = T.let(T.unsafe(nil), Integer)
Mongo::Protocol::Serializers::Sections::PayloadZero::TYPE_BYTE = T.let(T.unsafe(nil), String)
Mongo::Protocol::Serializers::ZERO = T.let(T.unsafe(nil), Integer)

module Mongo::Protocol::Serializers::Zero
  class << self
    def serialize(buffer, value, validating_keys = T.unsafe(nil)); end
  end
end

class Mongo::Protocol::Update < ::Mongo::Protocol::Message
  def initialize(database, collection, selector, update, options = T.unsafe(nil)); end

  def flags; end
  def namespace; end
  def op_code; end
  def payload; end
  def selector; end
  def update; end
  def zero; end

  protected

  def upconverter; end
end

Mongo::Protocol::Update::FLAGS = T.let(T.unsafe(nil), Array)
Mongo::Protocol::Update::OP_CODE = T.let(T.unsafe(nil), Integer)

class Mongo::Protocol::Update::Upconverter
  def initialize(collection, filter, update, flags); end

  def collection; end
  def command; end
  def filter; end
  def flags; end
  def update; end
end

Mongo::Protocol::Update::Upconverter::MULTI = T.let(T.unsafe(nil), String)
Mongo::Protocol::Update::Upconverter::U = T.let(T.unsafe(nil), String)
Mongo::Protocol::Update::Upconverter::UPDATE = T.let(T.unsafe(nil), String)
Mongo::Protocol::Update::Upconverter::UPDATES = T.let(T.unsafe(nil), String)
Mongo::Protocol::Update::Upconverter::UPSERT = T.let(T.unsafe(nil), String)

module Mongo::QueryCache
  class << self
    def cache; end
    def clear; end
    def clear_namespace(namespace); end
    def enabled=(value); end
    def enabled?; end
    def get(**opts); end
    def set(cursor, **opts); end
    def uncached; end

    private

    def cache_key(**opts); end
    def cache_table; end
    def namespace_key(**opts); end
  end
end

class Mongo::QueryCache::Middleware
  def initialize(app); end

  def call(env); end
end

module Mongo::Retryable
  def legacy_write_with_retry(server = T.unsafe(nil), session = T.unsafe(nil)); end
  def nro_write_with_retry(session, write_concern, &block); end
  def read_with_one_retry(options = T.unsafe(nil)); end
  def read_with_retry(session = T.unsafe(nil), server_selector = T.unsafe(nil), &block); end
  def read_with_retry_cursor(session, server_selector, view, &block); end
  def write_with_retry(session, write_concern, ending_transaction = T.unsafe(nil), &block); end

  private

  def legacy_read_with_retry(session, server_selector); end
  def log_retry(e, options = T.unsafe(nil)); end
  def modern_read_with_retry(session, server_selector, &block); end
  def raise_unsupported_error(e); end
  def retry_read(original_error, server_selector, session, &block); end
  def retry_write(original_error, session, txn_num, &block); end
  def retry_write_allowed?(session, write_concern); end
  def select_server(cluster, server_selector, session); end
end

class Mongo::Semaphore
  def initialize; end

  def broadcast; end
  def signal; end
  def wait(timeout = T.unsafe(nil)); end
end

class Mongo::Server
  include ::Mongo::Loggable
  include ::Mongo::Monitoring::Publishable
  include ::Mongo::Event::Publisher
  extend ::Forwardable

  def initialize(address, cluster, monitoring, event_listeners, options = T.unsafe(nil)); end

  def ==(other); end
  def address; end
  def app_metadata(*args, &block); end
  def arbiter?(*args, &block); end
  def average_round_trip_time(*args, &block); end
  def check_driver_support!(*args, &block); end
  def clear_connection_pool(service_id: T.unsafe(nil)); end
  def cluster; end
  def cluster_time(*args, &block); end
  def compressor; end
  def connectable?; end
  def connected?; end
  def description; end
  def disconnect!; end
  def features(*args, &block); end
  def force_load_balancer?; end
  def ghost?(*args, &block); end
  def handle_auth_failure!; end
  def handle_handshake_failure!; end
  def heartbeat_frequency; end
  def heartbeat_frequency_seconds; end
  def inspect; end
  def last_scan; end
  def last_scan_monotime; end
  def last_write_date(*args, &block); end
  def load_balancer?(*args, &block); end
  def logical_session_timeout(*args, &block); end
  def matches_tag_set?(tag_set); end
  def max_bson_object_size(*args, &block); end
  def max_message_size(*args, &block); end
  def max_wire_version(*args, &block); end
  def max_write_batch_size(*args, &block); end
  def mongos?(*args, &block); end
  def monitor; end
  def monitor_app_metadata(*args, &block); end
  def monitoring; end
  def next_connection_id; end
  def options; end
  def other?(*args, &block); end
  def pool; end
  def primary?(*args, &block); end
  def publish_opening_event; end
  def push_monitor_app_metadata(*args, &block); end
  def reconnect!; end
  def replica_set_name(*args, &block); end
  def retry_reads?; end
  def retry_writes?; end
  def round_trip_time_averager; end
  def scan!(*args, &block); end
  def scan_semaphore; end
  def secondary?(*args, &block); end
  def standalone?(*args, &block); end
  def start_monitoring; end
  def status; end
  def summary; end
  def tags(*args, &block); end
  def unknown!(options = T.unsafe(nil)); end
  def unknown?(*args, &block); end
  def update_cluster_time(*args, &block); end
  def update_description(description); end
  def update_last_scan; end
  def with_connection(service_id: T.unsafe(nil), &block); end
end

class Mongo::Server::AppMetadata
  extend ::Forwardable

  def initialize(options = T.unsafe(nil)); end

  def purpose; end
  def server_api; end
  def validated_document; end
  def wrapping_libraries; end

  private

  def architecture; end
  def document; end
  def driver_doc; end
  def full_client_document; end
  def name; end
  def os_doc; end
  def platform; end
  def type; end
  def validate!; end
end

Mongo::Server::AppMetadata::AUTH_OPTION_KEYS = T.let(T.unsafe(nil), Array)
Mongo::Server::AppMetadata::DRIVER_NAME = T.let(T.unsafe(nil), String)
Mongo::Server::AppMetadata::MAX_APP_NAME_SIZE = T.let(T.unsafe(nil), Integer)
Mongo::Server::AppMetadata::MAX_DOCUMENT_SIZE = T.let(T.unsafe(nil), Integer)
Mongo::Server::AppMetadata::PURPOSES = T.let(T.unsafe(nil), Array)
Mongo::Server::CONNECT_TIMEOUT = T.let(T.unsafe(nil), Integer)

class Mongo::Server::Connection < ::Mongo::Server::ConnectionBase
  include ::Mongo::Retryable

  def initialize(server, options = T.unsafe(nil)); end

  def closed?; end
  def connect!; end
  def connection_pool; end
  def disconnect!(options = T.unsafe(nil)); end
  def error?; end
  def id; end
  def last_checkin; end
  def ping; end
  def record_checkin!; end
  def socket_timeout; end
  def timeout; end

  private

  def deliver(message, client, options = T.unsafe(nil)); end
  def do_connect; end
  def handle_errors; end
end

Mongo::Server::Connection::PING = T.let(T.unsafe(nil), Hash)
Mongo::Server::Connection::PING_BYTES = T.let(T.unsafe(nil), String)
Mongo::Server::Connection::PING_MESSAGE = T.let(T.unsafe(nil), Mongo::Protocol::Query)
Mongo::Server::Connection::PING_OP_MSG = T.let(T.unsafe(nil), Hash)
Mongo::Server::Connection::PING_OP_MSG_BYTES = T.let(T.unsafe(nil), String)
Mongo::Server::Connection::PING_OP_MSG_MESSAGE = T.let(T.unsafe(nil), Mongo::Protocol::Msg)

class Mongo::Server::ConnectionBase < ::Mongo::Server::ConnectionCommon
  include ::Mongo::Loggable
  include ::Mongo::Monitoring::Publishable
  extend ::Forwardable

  def address(*args, &block); end
  def app_metadata; end
  def cluster_time(*args, &block); end
  def description; end
  def dispatch(messages, context, options = T.unsafe(nil)); end
  def features(*args, &block); end
  def generation; end
  def max_bson_object_size(*args, &block); end
  def max_message_size(*args, &block); end
  def mongos?(*args, &block); end
  def options; end
  def server; end
  def service_id; end
  def update_cluster_time(*args, &block); end

  private

  def deliver(message, context, options = T.unsafe(nil)); end
  def serialize(message, context, buffer = T.unsafe(nil)); end
end

Mongo::Server::ConnectionBase::DEFAULT_MAX_BSON_OBJECT_SIZE = T.let(T.unsafe(nil), Integer)
Mongo::Server::ConnectionBase::MAX_BSON_COMMAND_OVERHEAD = T.let(T.unsafe(nil), Integer)
Mongo::Server::ConnectionBase::REDUCED_MAX_BSON_SIZE = T.let(T.unsafe(nil), Integer)

class Mongo::Server::ConnectionCommon
  def compressor; end
  def connected?; end
  def handshake_command(handshake_document); end
  def handshake_document(app_metadata, speculative_auth_doc: T.unsafe(nil), load_balancer: T.unsafe(nil), server_api: T.unsafe(nil)); end
  def pid; end

  private

  def add_server_diagnostics; end
  def ensure_connected; end
  def set_compressor!(reply); end
  def socket; end
  def ssl_options; end
end

Mongo::Server::ConnectionCommon::HELLO_DOC = T.let(T.unsafe(nil), BSON::Document)
Mongo::Server::ConnectionCommon::LEGACY_HELLO_DOC = T.let(T.unsafe(nil), BSON::Document)

class Mongo::Server::ConnectionPool
  include ::Mongo::Loggable
  include ::Mongo::Monitoring::Publishable
  extend ::Forwardable

  def initialize(server, options = T.unsafe(nil)); end

  def address(*args, &block); end
  def available_count; end
  def check_in(connection); end
  def check_out(service_id: T.unsafe(nil)); end
  def clear(options = T.unsafe(nil)); end
  def close(options = T.unsafe(nil)); end
  def close_idle_sockets; end
  def closed?; end
  def disconnect!(options = T.unsafe(nil)); end
  def generation(*args, &block); end
  def generation_manager; end
  def inspect; end
  def max_idle_time; end
  def max_size; end
  def min_size; end
  def monitoring(*args, &block); end
  def options; end
  def populate; end
  def populate_semaphore; end
  def populator; end
  def size; end
  def stop_populator; end
  def summary; end
  def wait_timeout; end
  def with_connection(service_id: T.unsafe(nil)); end

  private

  def check_invariants; end
  def connect_connection(connection); end
  def create_and_add_connection; end
  def create_connection; end
  def next_available_connection(service_id: T.unsafe(nil)); end
  def raise_if_closed!; end
  def unsynchronized_size; end

  class << self
    def finalize(available_connections, pending_connections, populator); end
  end
end

Mongo::Server::ConnectionPool::DEFAULT_MAX_SIZE = T.let(T.unsafe(nil), Integer)
Mongo::Server::ConnectionPool::DEFAULT_MIN_SIZE = T.let(T.unsafe(nil), Integer)
Mongo::Server::ConnectionPool::DEFAULT_WAIT_TIMEOUT = T.let(T.unsafe(nil), Integer)

class Mongo::Server::ConnectionPool::GenerationManager
  def initialize(server:); end

  def bump(service_id: T.unsafe(nil)); end
  def generation(service_id: T.unsafe(nil)); end
  def server; end
end

class Mongo::Server::Description
  def initialize(address, config = T.unsafe(nil), average_round_trip_time: T.unsafe(nil), load_balancer: T.unsafe(nil), force_load_balancer: T.unsafe(nil)); end

  def ==(other); end
  def address; end
  def arbiter?; end
  def arbiters; end
  def average_round_trip_time; end
  def config; end
  def data_bearing?; end
  def election_id; end
  def eql?(other); end
  def features; end
  def ghost?; end
  def hidden?; end
  def hosts; end
  def inspect; end
  def is_server?(server); end
  def last_update_monotime; end
  def last_update_time; end
  def last_write_date; end
  def lists_server?(server); end
  def load_balancer?; end
  def logical_session_timeout; end
  def max_bson_object_size; end
  def max_message_size; end
  def max_wire_version; end
  def max_write_batch_size; end
  def me; end
  def me_mismatch?; end
  def min_wire_version; end
  def mongos?; end
  def ok?; end
  def op_time; end
  def other?; end
  def passive?; end
  def passives; end
  def primary?; end
  def primary_host; end
  def replica_set_member?; end
  def replica_set_name; end
  def secondary?; end
  def server_connection_id; end
  def server_type; end
  def server_version_gte?(version); end
  def servers; end
  def service_id; end
  def set_version; end
  def standalone?; end
  def tags; end
  def topology_version; end
  def topology_version_gt?(other_desc); end
  def topology_version_gte?(other_desc); end
  def unknown?; end
  def wire_versions; end
end

Mongo::Server::Description::ARBITER = T.let(T.unsafe(nil), String)
Mongo::Server::Description::ARBITERS = T.let(T.unsafe(nil), String)
Mongo::Server::Description::CONNECTION_ID = T.let(T.unsafe(nil), String)
Mongo::Server::Description::DEFAULT_MAX_WRITE_BATCH_SIZE = T.let(T.unsafe(nil), Integer)
Mongo::Server::Description::ELECTION_ID = T.let(T.unsafe(nil), String)
Mongo::Server::Description::EXCLUDE_FOR_COMPARISON = T.let(T.unsafe(nil), Array)

class Mongo::Server::Description::Features
  def initialize(server_wire_versions, address = T.unsafe(nil)); end

  def array_filters_enabled?; end
  def check_driver_support!; end
  def collation_enabled?; end
  def commit_quorum_enabled?; end
  def find_and_modify_option_validation_enabled?; end
  def find_command_enabled?; end
  def list_collections_enabled?; end
  def list_indexes_enabled?; end
  def max_staleness_enabled?; end
  def merge_out_on_secondary_enabled?; end
  def op_msg_enabled?; end
  def retryable_write_error_label_enabled?; end
  def scram_sha_1_enabled?; end
  def scram_sha_256_enabled?; end
  def server_wire_versions; end
  def sessions_enabled?; end
  def transactions_enabled?; end
  def update_delete_option_validation_enabled?; end
  def users_info_enabled?; end
  def write_command_enabled?; end
end

Mongo::Server::Description::Features::DRIVER_TOO_OLD = T.let(T.unsafe(nil), String)
Mongo::Server::Description::Features::DRIVER_WIRE_VERSIONS = T.let(T.unsafe(nil), Range)
Mongo::Server::Description::Features::MAPPINGS = T.let(T.unsafe(nil), Hash)
Mongo::Server::Description::Features::SERVER_TOO_OLD = T.let(T.unsafe(nil), String)
Mongo::Server::Description::HIDDEN = T.let(T.unsafe(nil), String)
Mongo::Server::Description::HOSTS = T.let(T.unsafe(nil), String)
Mongo::Server::Description::LAST_WRITE = T.let(T.unsafe(nil), String)
Mongo::Server::Description::LAST_WRITE_DATE = T.let(T.unsafe(nil), String)
Mongo::Server::Description::LEGACY_WIRE_VERSION = T.let(T.unsafe(nil), Integer)
Mongo::Server::Description::LOCAL_TIME = T.let(T.unsafe(nil), String)
Mongo::Server::Description::LOGICAL_SESSION_TIMEOUT_MINUTES = T.let(T.unsafe(nil), String)

class Mongo::Server::Description::LoadBalancer
  def initialize(address); end

  def address; end
end

Mongo::Server::Description::MAX_BSON_OBJECT_SIZE = T.let(T.unsafe(nil), String)
Mongo::Server::Description::MAX_MESSAGE_BYTES = T.let(T.unsafe(nil), String)
Mongo::Server::Description::MAX_WIRE_VERSION = T.let(T.unsafe(nil), String)
Mongo::Server::Description::MAX_WRITE_BATCH_SIZE = T.let(T.unsafe(nil), String)
Mongo::Server::Description::ME = T.let(T.unsafe(nil), String)
Mongo::Server::Description::MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Server::Description::MIN_WIRE_VERSION = T.let(T.unsafe(nil), String)
Mongo::Server::Description::MONGOS_MESSAGE = T.let(T.unsafe(nil), String)
Mongo::Server::Description::OPERATION_TIME = T.let(T.unsafe(nil), String)
Mongo::Server::Description::PASSIVE = T.let(T.unsafe(nil), String)
Mongo::Server::Description::PASSIVES = T.let(T.unsafe(nil), String)
Mongo::Server::Description::PRIMARY = T.let(T.unsafe(nil), String)
Mongo::Server::Description::PRIMARY_HOST = T.let(T.unsafe(nil), String)
Mongo::Server::Description::REPLICA_SET = T.let(T.unsafe(nil), String)
Mongo::Server::Description::SECONDARY = T.let(T.unsafe(nil), String)
Mongo::Server::Description::SET_NAME = T.let(T.unsafe(nil), String)
Mongo::Server::Description::SET_VERSION = T.let(T.unsafe(nil), String)
Mongo::Server::Description::TAGS = T.let(T.unsafe(nil), String)

class Mongo::Server::Monitor
  include ::Mongo::Loggable
  include ::Mongo::Event::Publisher
  include ::Mongo::BackgroundThread
  extend ::Forwardable

  def initialize(server, event_listeners, monitoring, options = T.unsafe(nil)); end

  def compressor(*args, &block); end
  def connection; end
  def do_work; end
  def heartbeat_interval; end
  def last_scan(*args, &block); end
  def monitoring; end
  def options; end
  def push_monitor; end
  def restart!; end
  def run_sdam_flow(result, awaited: T.unsafe(nil)); end
  def scan!; end
  def server; end
  def stop!; end
  def stop_push_monitor!; end

  private

  def check; end
  def do_scan; end
  def pre_stop; end
  def throttle_scan_frequency!; end
end

class Mongo::Server::Monitor::AppMetadata < ::Mongo::Server::AppMetadata
  def initialize(options = T.unsafe(nil)); end
end

class Mongo::Server::Monitor::Connection < ::Mongo::Server::ConnectionCommon
  include ::Mongo::Loggable

  def initialize(address, options = T.unsafe(nil)); end

  def address; end
  def check_document; end
  def connect!; end
  def disconnect!(options = T.unsafe(nil)); end
  def dispatch(message); end
  def dispatch_bytes(bytes, **opts); end
  def handshake!; end
  def options; end
  def read_response(**opts); end
  def server_connection_id; end
  def socket_timeout; end
  def write_bytes(bytes); end

  private

  def add_server_connection_id; end
  def hello_ok?; end
  def set_hello_ok!(reply); end
end

Mongo::Server::Monitor::DEFAULT_HEARTBEAT_INTERVAL = T.let(T.unsafe(nil), Integer)
Mongo::Server::Monitor::MIN_SCAN_INTERVAL = T.let(T.unsafe(nil), Float)
Mongo::Server::Monitor::RTT_WEIGHT_FACTOR = T.let(T.unsafe(nil), Float)

class Mongo::Server::PendingConnection < ::Mongo::Server::ConnectionBase
  def initialize(socket, server, monitoring, options = T.unsafe(nil)); end

  def handshake_and_authenticate!; end
  def id; end

  private

  def authenticate!(speculative_auth_client_nonce: T.unsafe(nil), speculative_auth_mech: T.unsafe(nil), speculative_auth_result: T.unsafe(nil)); end
  def default_mechanism; end
  def ensure_connected; end
  def handshake!(speculative_auth_doc: T.unsafe(nil)); end
  def post_handshake(response, average_rtt); end
  def resolved_user(speculative_auth_mech: T.unsafe(nil)); end
end

class Mongo::Server::Populator
  include ::Mongo::Loggable
  include ::Mongo::BackgroundThread

  def initialize(pool, options = T.unsafe(nil)); end

  def options; end
  def pre_stop; end

  private

  def do_work; end
end

class Mongo::Server::PushMonitor
  include ::Mongo::Loggable
  include ::Mongo::BackgroundThread
  extend ::Forwardable

  def initialize(monitor, topology_version, monitoring, **options); end

  def check; end
  def do_work; end
  def monitor; end
  def monitoring; end
  def options; end
  def read_response; end
  def server(*args, &block); end
  def start!; end
  def stop!; end
  def topology_version; end
  def write_check_command; end
end

class Mongo::Server::PushMonitor::Connection < ::Mongo::Server::Monitor::Connection
  def socket_timeout; end
end

class Mongo::Server::RoundTripTimeAverager
  def initialize; end

  def average_round_trip_time; end
  def last_round_trip_time; end
  def measure; end

  private

  def update_average_round_trip_time; end
end

Mongo::Server::RoundTripTimeAverager::RTT_WEIGHT_FACTOR = T.let(T.unsafe(nil), Float)

module Mongo::ServerSelector
  extend ::Mongo::ServerSelector

  def get(preference = T.unsafe(nil)); end
  def primary; end
end

class Mongo::ServerSelector::Base
  def initialize(options = T.unsafe(nil)); end

  def ==(other); end
  def candidates(cluster); end
  def hedge; end
  def inspect; end
  def local_threshold; end
  def local_threshold_with_cluster(cluster); end
  def max_staleness; end
  def options; end
  def select_server(cluster, ping = T.unsafe(nil), session = T.unsafe(nil), write_aggregation: T.unsafe(nil)); end
  def server_selection_timeout; end
  def suitable_servers(cluster); end
  def tag_sets; end
  def try_select_server(cluster, write_aggregation: T.unsafe(nil)); end

  private

  def filter_stale_servers(candidates, primary = T.unsafe(nil)); end
  def full_doc; end
  def match_tag_sets(candidates); end
  def near_servers(candidates = T.unsafe(nil), local_threshold = T.unsafe(nil)); end
  def primary(candidates); end
  def secondaries(candidates); end
  def server_selection_diagnostic_message(cluster); end
  def validate!; end
  def validate_max_staleness_support!(server); end
  def validate_max_staleness_value!(cluster); end
  def validate_max_staleness_value_early!; end
  def wait_for_server_selection(cluster, time_remaining); end
end

Mongo::ServerSelector::LOCAL_THRESHOLD = T.let(T.unsafe(nil), Float)

class Mongo::ServerSelector::Nearest < ::Mongo::ServerSelector::Base
  def hedge_allowed?; end
  def name; end
  def secondary_ok?; end
  def tags_allowed?; end
  def to_doc; end
  def to_mongos; end

  private

  def max_staleness_allowed?; end
  def select_in_replica_set(candidates); end
end

Mongo::ServerSelector::Nearest::SERVER_FORMATTED_NAME = T.let(T.unsafe(nil), String)
Mongo::ServerSelector::PREFERENCES = T.let(T.unsafe(nil), Hash)
Mongo::ServerSelector::PRIMARY = T.let(T.unsafe(nil), Mongo::Options::Redacted)

class Mongo::ServerSelector::Primary < ::Mongo::ServerSelector::Base
  def hedge_allowed?; end
  def name; end
  def secondary_ok?; end
  def tags_allowed?; end
  def to_doc; end
  def to_mongos; end

  private

  def max_staleness_allowed?; end
  def select_in_replica_set(candidates); end
end

Mongo::ServerSelector::Primary::SERVER_FORMATTED_NAME = T.let(T.unsafe(nil), String)

class Mongo::ServerSelector::PrimaryPreferred < ::Mongo::ServerSelector::Base
  def hedge_allowed?; end
  def name; end
  def secondary_ok?; end
  def tags_allowed?; end
  def to_doc; end
  def to_mongos; end

  private

  def max_staleness_allowed?; end
  def select_in_replica_set(candidates); end
end

Mongo::ServerSelector::PrimaryPreferred::SERVER_FORMATTED_NAME = T.let(T.unsafe(nil), String)
Mongo::ServerSelector::SERVER_SELECTION_TIMEOUT = T.let(T.unsafe(nil), Integer)
Mongo::ServerSelector::SMALLEST_MAX_STALENESS_SECONDS = T.let(T.unsafe(nil), Integer)

class Mongo::ServerSelector::Secondary < ::Mongo::ServerSelector::Base
  def hedge_allowed?; end
  def name; end
  def secondary_ok?; end
  def tags_allowed?; end
  def to_doc; end
  def to_mongos; end

  private

  def max_staleness_allowed?; end
  def select_in_replica_set(candidates); end
end

Mongo::ServerSelector::Secondary::SERVER_FORMATTED_NAME = T.let(T.unsafe(nil), String)

class Mongo::ServerSelector::SecondaryPreferred < ::Mongo::ServerSelector::Base
  def hedge_allowed?; end
  def name; end
  def secondary_ok?; end
  def tags_allowed?; end
  def to_doc; end
  def to_mongos; end

  private

  def max_staleness_allowed?; end
  def select_in_replica_set(candidates); end
end

Mongo::ServerSelector::SecondaryPreferred::SERVER_FORMATTED_NAME = T.let(T.unsafe(nil), String)

class Mongo::Session
  include ::Mongo::Retryable
  include ::Mongo::Loggable
  include ::Mongo::ClusterTime::Consumer
  extend ::Forwardable

  def initialize(server_session, client, options = T.unsafe(nil)); end

  def abort_transaction; end
  def aborting_transaction?; end
  def add_autocommit!(command); end
  def add_start_transaction!(command); end
  def add_txn_num!(command); end
  def add_txn_opts!(command, read); end
  def advance_operation_time(new_operation_time); end
  def client; end
  def cluster; end
  def commit_transaction(options = T.unsafe(nil)); end
  def committing_transaction?; end
  def end_session; end
  def ended?; end
  def explicit?; end
  def implicit?; end
  def in_transaction?; end
  def inspect; end
  def next_txn_num; end
  def operation_time; end
  def options; end
  def pin_to_server(server); end
  def pin_to_service(service_id); end
  def pinned_server; end
  def pinned_service_id; end
  def process(result); end
  def recovery_token; end
  def recovery_token=(_arg0); end
  def retry_reads?; end
  def retry_writes?; end
  def session_id; end
  def snapshot?; end
  def snapshot_timestamp; end
  def snapshot_timestamp=(_arg0); end
  def start_transaction(options = T.unsafe(nil)); end
  def starting_transaction?; end
  def suppress_read_write_concern!(command); end
  def txn_num; end
  def txn_options; end
  def txn_read_preference; end
  def unpin; end
  def unpin_maybe(error); end
  def update_state!; end
  def validate!(client); end
  def validate_read_preference!(command); end
  def with_transaction(options = T.unsafe(nil)); end

  private

  def causal_consistency?; end
  def causal_consistency_doc; end
  def check_if_ended!; end
  def check_if_no_transaction!; end
  def check_matching_cluster!(client); end
  def set_operation_time(result); end
  def txn_read_concern; end
  def txn_write_concern; end
  def within_states?(*states); end
end

Mongo::Session::MISMATCHED_CLUSTER_ERROR_MSG = T.let(T.unsafe(nil), String)
Mongo::Session::NO_TRANSACTION_STATE = T.let(T.unsafe(nil), Symbol)
Mongo::Session::SESSIONS_NOT_SUPPORTED = T.let(T.unsafe(nil), String)
Mongo::Session::SESSION_ENDED_ERROR_MSG = T.let(T.unsafe(nil), String)
Mongo::Session::STARTING_TRANSACTION_STATE = T.let(T.unsafe(nil), Symbol)

class Mongo::Session::ServerSession
  def initialize; end

  def inspect; end
  def last_use; end
  def next_txn_num; end
  def session_id; end
  def set_last_use!; end
  def txn_num; end
end

Mongo::Session::ServerSession::DASH_REGEX = T.let(T.unsafe(nil), Regexp)
Mongo::Session::ServerSession::UUID_PACK = T.let(T.unsafe(nil), String)

class Mongo::Session::SessionPool
  def initialize(cluster); end

  def checkin(session); end
  def checkout; end
  def end_sessions; end
  def inspect; end

  private

  def about_to_expire?(session); end
  def prune!; end

  class << self
    def create(cluster); end
  end
end

Mongo::Session::TRANSACTION_ABORTED_STATE = T.let(T.unsafe(nil), Symbol)
Mongo::Session::TRANSACTION_COMMITTED_STATE = T.let(T.unsafe(nil), Symbol)
Mongo::Session::TRANSACTION_IN_PROGRESS_STATE = T.let(T.unsafe(nil), Symbol)
Mongo::Session::UNLABELED_WRITE_CONCERN_CODES = T.let(T.unsafe(nil), Array)

class Mongo::Socket
  include ::Socket::Constants

  def initialize(timeout, options); end

  def alive?; end
  def close; end
  def connectable?; end
  def connection_address; end
  def connection_generation; end
  def eof?; end
  def family; end
  def gets(*args); end
  def monitor?; end
  def options; end
  def read(length, timeout: T.unsafe(nil)); end
  def readbyte; end
  def socket; end
  def summary; end
  def timeout; end
  def write(*args); end

  private

  def allocate_string(capacity); end
  def do_write(*args); end
  def human_address; end
  def map_exceptions; end
  def read_buffer_size; end
  def read_from_socket(length, timeout: T.unsafe(nil)); end
  def set_keepalive_opts(sock); end
  def set_option(sock, option, default); end
  def set_socket_options(sock); end
  def unix_socket?(sock); end
end

Mongo::Socket::DEFAULT_TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Mongo::Socket::DEFAULT_TCP_KEEPIDLE = T.let(T.unsafe(nil), Integer)
Mongo::Socket::DEFAULT_TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)

module Mongo::Socket::OcspCache
  private

  def clear; end
  def delete(cert_id); end
  def get(cert_id); end
  def responses; end
  def set(cert_id, response); end

  class << self
    def clear; end
    def delete(cert_id); end
    def get(cert_id); end
    def responses; end
    def set(cert_id, response); end
  end
end

Mongo::Socket::OcspCache::LOCK = T.let(T.unsafe(nil), Thread::Mutex)

class Mongo::Socket::OcspVerifier
  include ::Mongo::Loggable

  def initialize(host_name, cert, ca_cert, cert_store, **opts); end

  def ca_cert; end
  def cert; end
  def cert_id; end
  def cert_store; end
  def host_name; end
  def ocsp_uris; end
  def options; end
  def timeout; end
  def verify; end
  def verify_with_cache; end

  private

  def do_verify; end
  def handle_exceptions; end
  def raise_revoked_error(resp); end
  def report_response_body(body); end
  def report_uri(original_uri, uri); end
  def return_ocsp_response(resp, errors = T.unsafe(nil)); end
  def verify_one_responder(uri); end
end

class Mongo::Socket::SSL < ::Mongo::Socket
  include ::OpenSSL

  def initialize(host, port, host_name, timeout, family, options = T.unsafe(nil)); end

  def context; end
  def host; end
  def host_name; end
  def port; end
  def readbyte; end

  private

  def connect!; end
  def create_context(options); end
  def human_address; end
  def load_private_key(text, passphrase); end
  def read_buffer_size; end
  def run_tls_context_hooks; end
  def set_cert(context, options); end
  def set_cert_verification(context, options); end
  def set_key(context, options); end
  def verify_certificate!(socket); end
  def verify_certificate?; end
  def verify_hostname?; end
  def verify_ocsp_endpoint!(socket); end
  def verify_ocsp_endpoint?; end
end

Mongo::Socket::SSL_ERROR = T.let(T.unsafe(nil), String)

class Mongo::Socket::TCP < ::Mongo::Socket
  def initialize(host, port, timeout, family, options = T.unsafe(nil)); end

  def host; end
  def port; end

  private

  def connect!; end
  def human_address; end
end

Mongo::Socket::TIMEOUT_ERROR = T.let(T.unsafe(nil), String)
Mongo::Socket::TIMEOUT_PACK = T.let(T.unsafe(nil), String)

class Mongo::Socket::Unix < ::Mongo::Socket
  def initialize(path, timeout, options = T.unsafe(nil)); end

  def path; end

  private

  def human_address; end
end

Mongo::Socket::WRITE_CHUNK_SIZE = T.let(T.unsafe(nil), Integer)
module Mongo::Srv; end

class Mongo::Srv::Monitor
  include ::Mongo::Loggable
  include ::Mongo::BackgroundThread

  def initialize(cluster, **opts); end

  def cluster; end
  def last_result; end
  def options; end

  private

  def do_work; end
  def scan!; end
  def scan_interval; end
  def timeout; end
end

Mongo::Srv::Monitor::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)
Mongo::Srv::Monitor::MIN_SCAN_INTERVAL = T.let(T.unsafe(nil), Integer)

class Mongo::Srv::Resolver
  include ::Mongo::Loggable

  def initialize(**opts); end

  def get_records(hostname); end
  def get_txt_options_string(hostname); end
  def options; end
  def timeout; end

  private

  def raise_on_invalid?; end
end

Mongo::Srv::Resolver::RECORD_PREFIX = T.let(T.unsafe(nil), String)

class Mongo::Srv::Result
  include ::Mongo::Address::Validator

  def initialize(hostname); end

  def add_record(record); end
  def address_strs; end
  def empty?; end
  def min_ttl; end
  def min_ttl=(_arg0); end
  def query_hostname; end

  private

  def normalize_hostname(host); end
  def validate_same_origin!(record_host); end
end

Mongo::Srv::Result::MISMATCHED_DOMAINNAME = T.let(T.unsafe(nil), String)

module Mongo::Timeout
  private

  def timeout(sec, klass = T.unsafe(nil), message = T.unsafe(nil)); end

  class << self
    def timeout(sec, klass = T.unsafe(nil), message = T.unsafe(nil)); end
  end
end

class Mongo::TopologyVersion < ::BSON::Document
  def initialize(doc); end

  def counter; end
  def gt?(other); end
  def gte?(other); end
  def process_id; end
  def to_doc; end
end

class Mongo::URI
  include ::Mongo::Loggable
  include ::Mongo::Address::Validator

  def initialize(string, options = T.unsafe(nil)); end

  def client_options; end
  def credentials; end
  def database; end
  def options; end
  def servers; end
  def srv_records; end
  def uri_options; end

  private

  def decode(value); end
  def encode(value); end
  def extract_db_opts!(string); end
  def options_mapper; end
  def parse!(remaining); end
  def parse_database!(string); end
  def parse_password!(string); end
  def parse_uri_options!(string); end
  def parse_user!(string); end
  def raise_invalid_error!(details); end
  def raise_invalid_error_no_fmt!(details); end
  def scheme; end
  def validate_uri_options!; end

  class << self
    def get(string, opts = T.unsafe(nil)); end
  end
end

Mongo::URI::AUTH_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::AUTH_MECH_MAP = T.let(T.unsafe(nil), Hash)
Mongo::URI::AUTH_USER_PWD_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::DATABASE_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::FORMAT = T.let(T.unsafe(nil), String)
Mongo::URI::HELP = T.let(T.unsafe(nil), String)
Mongo::URI::HOST_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::HOST_PORT_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::INDIV_URI_OPTS_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::INVALID_HOST = T.let(T.unsafe(nil), String)
Mongo::URI::INVALID_OPTS_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::INVALID_OPTS_VALUE_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::INVALID_PORT = T.let(T.unsafe(nil), String)
Mongo::URI::INVALID_SCHEME = T.let(T.unsafe(nil), String)
Mongo::URI::MONGODB_SCHEME = T.let(T.unsafe(nil), String)
Mongo::URI::MONGODB_SRV_SCHEME = T.let(T.unsafe(nil), String)

class Mongo::URI::OptionsMapper
  include ::Mongo::Loggable

  def initialize(**opts); end

  def add_uri_option(key, value, uri_options); end
  def options; end
  def ruby_to_smc(opts); end
  def smc_to_ruby(opts); end

  private

  def apply_transform(key, value, type); end
  def convert_array(name, value); end
  def convert_auth_mech(name, value); end
  def convert_auth_mech_props(name, value); end
  def convert_bool(name, value); end
  def convert_integer(name, value); end
  def convert_inverse_bool(name, value); end
  def convert_max_staleness(name, value); end
  def convert_ms(name, value); end
  def convert_read_mode(name, value); end
  def convert_read_set(name, value); end
  def convert_read_tags(name, value); end
  def convert_repeated_bool(name, value); end
  def convert_symbol(name, value); end
  def convert_w(name, value); end
  def convert_zlib_compression_level(name, value); end
  def hash_extractor(name, value); end
  def merge_uri_option(target, value, name); end
  def revert_array(value); end
  def revert_auth_mech(value); end
  def revert_auth_mech_props(value); end
  def revert_bool(value); end
  def revert_integer(value); end
  def revert_inverse_bool(value); end
  def revert_max_staleness(value); end
  def revert_ms(value); end
  def revert_read_mode(value); end
  def revert_read_tags(value); end
  def revert_repeated_bool(value); end
  def revert_symbol(value); end
  def revert_w(value); end
  def revert_zlib_compression_level(value); end

  class << self
    def uri_option(uri_key, name, **extra); end
  end
end

Mongo::URI::OptionsMapper::URI_OPTION_CANONICAL_NAMES = T.let(T.unsafe(nil), Hash)
Mongo::URI::OptionsMapper::URI_OPTION_MAP = T.let(T.unsafe(nil), Hash)
Mongo::URI::PERCENT_CHAR = T.let(T.unsafe(nil), Regexp)
Mongo::URI::READ_MODE_MAP = T.let(T.unsafe(nil), Hash)
Mongo::URI::REPEATABLE_OPTIONS = T.let(T.unsafe(nil), Array)
Mongo::URI::SCHEME = T.let(T.unsafe(nil), String)
Mongo::URI::SCHEME_DELIM = T.let(T.unsafe(nil), String)

class Mongo::URI::SRVProtocol < ::Mongo::URI
  def client_options; end
  def query_hostname; end
  def srv_records; end
  def srv_result; end

  private

  def get_txt_options(hostname); end
  def parse!(remaining); end
  def parse_txt_options!(string); end
  def raise_invalid_error!(details); end
  def resolver; end
  def scheme; end
  def validate_srv_hostname(hostname); end
  def validate_uri_options!; end
end

Mongo::URI::SRVProtocol::DOT_PARTITION = T.let(T.unsafe(nil), String)
Mongo::URI::SRVProtocol::FORMAT = T.let(T.unsafe(nil), String)
Mongo::URI::SRVProtocol::INVALID_DOMAIN = T.let(T.unsafe(nil), String)
Mongo::URI::SRVProtocol::INVALID_HOST = T.let(T.unsafe(nil), String)
Mongo::URI::SRVProtocol::INVALID_PORT = T.let(T.unsafe(nil), String)
Mongo::URI::SRVProtocol::NO_SRV_RECORDS = T.let(T.unsafe(nil), String)
Mongo::URI::SRVProtocol::VALID_TXT_OPTIONS = T.let(T.unsafe(nil), Array)
Mongo::URI::UNESCAPED_DATABASE = T.let(T.unsafe(nil), String)
Mongo::URI::UNESCAPED_UNIX_SOCKET = T.let(T.unsafe(nil), String)
Mongo::URI::UNESCAPED_USER_PWD = T.let(T.unsafe(nil), String)
Mongo::URI::UNIX_SOCKET = T.let(T.unsafe(nil), Regexp)
Mongo::URI::UNSAFE = T.let(T.unsafe(nil), Regexp)
Mongo::URI::URI_OPTS_DELIM = T.let(T.unsafe(nil), String)
Mongo::URI::URI_OPTS_VALUE_DELIM = T.let(T.unsafe(nil), String)

module Mongo::Utils
  private

  def camelize(sym); end
  def excerpt_backtrace(exc, **opts); end
  def monotonic_time; end
  def shallow_camelize_keys(hash); end
  def shallow_symbolize_keys(hash); end
  def transform_server_api(server_api); end
  def warn_bg_exception(msg, exc, **opts); end

  class << self
    def camelize(sym); end
    def excerpt_backtrace(exc, **opts); end
    def monotonic_time; end
    def shallow_camelize_keys(hash); end
    def shallow_symbolize_keys(hash); end
    def transform_server_api(server_api); end
    def warn_bg_exception(msg, exc, **opts); end
  end
end

class Mongo::Utils::LocalLogger
  include ::Mongo::Loggable

  def initialize(**opts); end

  def options; end
end

Mongo::VERSION = T.let(T.unsafe(nil), String)

module Mongo::WriteConcern
  extend ::Mongo::WriteConcern

  def get(options); end
end

class Mongo::WriteConcern::Acknowledged < ::Mongo::WriteConcern::Base
  def acknowledged?; end
  def get_last_error; end
  def inspect; end
end

class Mongo::WriteConcern::Base
  def initialize(options); end

  def options; end
end

Mongo::WriteConcern::DEFAULT = T.let(T.unsafe(nil), Hash)
Mongo::WriteConcern::FSYNC = T.let(T.unsafe(nil), Symbol)
Mongo::WriteConcern::GET_LAST_ERROR = T.let(T.unsafe(nil), Symbol)
Mongo::WriteConcern::J = T.let(T.unsafe(nil), Symbol)

class Mongo::WriteConcern::Unacknowledged < ::Mongo::WriteConcern::Base
  def acknowledged?; end
  def get_last_error; end
  def inspect; end
end

Mongo::WriteConcern::W = T.let(T.unsafe(nil), Symbol)
Mongo::WriteConcern::WTIMEOUT = T.let(T.unsafe(nil), Symbol)

class Symbol
  include ::Comparable
  include ::BSON::Symbol
  extend ::BSON::Symbol::ClassMethods

  def bson_type; end
end

module UnicodeNormalize; end
